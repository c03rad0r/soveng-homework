// test/mocks/relay-mock.ts
import { EventEmitter as EventEmitter3 } from "node:events";

// src/relay/index.ts
import debug2 from "debug";
import { EventEmitter as EventEmitter2 } from "tseep";

// src/utils/normalize-url.ts
function tryNormalizeRelayUrl(url) {
  try {
    return normalizeRelayUrl(url);
  } catch {
    return void 0;
  }
}
function normalizeRelayUrl(url) {
  let r = normalizeUrl(url, {
    stripAuthentication: false,
    stripWWW: false,
    stripHash: true
  });
  if (!r.endsWith("/")) {
    r += "/";
  }
  return r;
}
function normalize(urls) {
  const normalized = /* @__PURE__ */ new Set();
  for (const url of urls) {
    try {
      normalized.add(normalizeRelayUrl(url));
    } catch {
    }
  }
  return Array.from(normalized);
}
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
var supportedProtocols = /* @__PURE__ */ new Set(["https:", "http:", "file:"]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  const type = match.groups?.type ?? "";
  const data = match.groups?.data ?? "";
  let hash = match.groups?.hash ?? "";
  const mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [...attributes];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options = {}) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  urlObject.hostname = urlObject.hostname.toLowerCase();
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (; ; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = `${pathComponents.slice(1).join("/")}/`;
    }
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// src/events/index.ts
import { EventEmitter } from "tseep";

// src/relay/sets/calculate.ts
import createDebug from "debug";

// src/outbox/write.ts
function getRelaysForSync(ndk, author, type = "write") {
  if (!ndk.outboxTracker) return void 0;
  const item = ndk.outboxTracker.data.get(author);
  if (!item) return void 0;
  if (type === "write") {
    return item.writeRelays;
  }
  return item.readRelays;
}
async function getWriteRelaysFor(ndk, author, type = "write") {
  if (!ndk.outboxTracker) return void 0;
  if (!ndk.outboxTracker.data.has(author)) {
    await ndk.outboxTracker.trackUsers([author]);
  }
  return getRelaysForSync(ndk, author, type);
}

// src/outbox/relay-ranking.ts
function getTopRelaysForAuthors(ndk, authors) {
  const relaysWithCount = /* @__PURE__ */ new Map();
  authors.forEach((author) => {
    const writeRelays = getRelaysForSync(ndk, author);
    if (writeRelays) {
      writeRelays.forEach((relay) => {
        const count = relaysWithCount.get(relay) || 0;
        relaysWithCount.set(relay, count + 1);
      });
    }
  });
  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);
  return sortedRelays.map((entry) => entry[0]);
}

// src/outbox/index.ts
function getAllRelaysForAllPubkeys(ndk, pubkeys, type = "read") {
  const pubkeysToRelays = /* @__PURE__ */ new Map();
  const authorsMissingRelays = /* @__PURE__ */ new Set();
  pubkeys.forEach((pubkey) => {
    const relays = getRelaysForSync(ndk, pubkey, type);
    if (relays && relays.size > 0) {
      relays.forEach((relay) => {
        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();
        pubkeysInRelay.add(pubkey);
      });
      pubkeysToRelays.set(pubkey, relays);
    } else {
      authorsMissingRelays.add(pubkey);
    }
  });
  return { pubkeysToRelays, authorsMissingRelays };
}
function chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {
  count ??= 2;
  preferredRelays ??= /* @__PURE__ */ new Set();
  const pool = ndk.pool;
  const connectedRelays = pool.connectedRelays();
  connectedRelays.forEach((relay) => {
    preferredRelays?.add(relay.url);
  });
  const relayToAuthorsMap = /* @__PURE__ */ new Map();
  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);
  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);
  const addAuthorToRelay = (author, relay) => {
    const authorsInRelay = relayToAuthorsMap.get(relay) || [];
    authorsInRelay.push(author);
    relayToAuthorsMap.set(relay, authorsInRelay);
  };
  for (const [author, authorRelays] of pubkeysToRelays.entries()) {
    let missingRelayCount = count;
    for (const relay of connectedRelays) {
      if (authorRelays.has(relay.url)) {
        addAuthorToRelay(author, relay.url);
        missingRelayCount--;
      }
    }
    for (const authorRelay of authorRelays) {
      if (relayToAuthorsMap.has(authorRelay)) {
        addAuthorToRelay(author, authorRelay);
        missingRelayCount--;
      }
    }
    if (missingRelayCount <= 0) continue;
    for (const relay of sortedRelays) {
      if (missingRelayCount <= 0) break;
      if (authorRelays.has(relay)) {
        addAuthorToRelay(author, relay);
        missingRelayCount--;
      }
    }
  }
  for (const author of authorsMissingRelays) {
    pool.permanentAndConnectedRelays().forEach((relay) => {
      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];
      authorsInRelay.push(author);
      relayToAuthorsMap.set(relay.url, authorsInRelay);
    });
  }
  return relayToAuthorsMap;
}

// src/outbox/read/with-authors.ts
function getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {
  return chooseRelayCombinationForPubkeys(ndk, authors, "write", { count: relayGoalPerAuthor });
}

// src/relay/sets/index.ts
var NDKPublishError = class extends Error {
  errors;
  publishedToRelays;
  /**
   * Intended relay set where the publishing was intended to happen.
   */
  intendedRelaySet;
  constructor(message, errors, publishedToRelays, intendedRelaySet) {
    super(message);
    this.errors = errors;
    this.publishedToRelays = publishedToRelays;
    this.intendedRelaySet = intendedRelaySet;
  }
  get relayErrors() {
    const errors = [];
    for (const [relay, err] of this.errors) {
      errors.push(`${relay.url}: ${err}`);
    }
    return errors.join("\n");
  }
};
var NDKRelaySet = class _NDKRelaySet {
  relays;
  debug;
  ndk;
  pool;
  constructor(relays, ndk, pool) {
    this.relays = relays;
    this.ndk = ndk;
    this.pool = pool ?? ndk.pool;
    this.debug = ndk.debug.extend("relayset");
  }
  /**
   * Adds a relay to this set.
   */
  addRelay(relay) {
    this.relays.add(relay);
  }
  get relayUrls() {
    return Array.from(this.relays).map((r) => r.url);
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * If no connection to the relay is found in the pool it will temporarily
   * connect to it.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected
   * @returns NDKRelaySet
   */
  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {
    pool = pool ?? ndk.pool;
    if (!pool) throw new Error("No pool provided");
    const relays = /* @__PURE__ */ new Set();
    for (const url of relayUrls) {
      const relay = pool.relays.get(normalizeRelayUrl(url));
      if (relay) {
        if (relay.status < 5 /* CONNECTED */ && connect) {
          relay.connect();
        }
        relays.add(relay);
      } else {
        const temporaryRelay = new NDKRelay(
          normalizeRelayUrl(url),
          ndk?.relayAuthDefaultPolicy,
          ndk
        );
        pool.useTemporaryRelay(
          temporaryRelay,
          void 0,
          `requested from fromRelayUrls ${relayUrls}`
        );
        relays.add(temporaryRelay);
      }
    }
    return new _NDKRelaySet(new Set(relays), ndk, pool);
  }
  /**
   * Publish an event to all relays in this relay set.
   *
   * This method implements a robust mechanism for publishing events to multiple relays with
   * built-in handling for race conditions, timeouts, and partial failures. The implementation
   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully
   * received an event.
   *
   * Key aspects of this implementation:
   *
   * 1. DUAL-TRACKING MECHANISM:
   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()
   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing
   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in
   *    the promise chain.
   *
   * 2. RACE CONDITION HANDLING:
   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success
   *    - If a relay times out after successfully publishing, we still count it as a success
   *    - All relay operations happen in parallel, with proper tracking regardless of completion order
   *
   * 3. TIMEOUT MANAGEMENT:
   *    - Individual timeouts for each relay operation
   *    - Proper cleanup of timeouts to prevent memory leaks
   *    - Clear timeout error reporting
   *
   * 4. ERROR HANDLING:
   *    - Detailed tracking of specific errors for each failed relay
   *    - Special handling for ephemeral events (which don't expect acknowledgement)
   *    - RequiredRelayCount parameter to control the minimum success threshold
   *
   * @param event Event to publish
   * @param timeoutMs Timeout in milliseconds for each relay publish operation
   * @param requiredRelayCount The minimum number of relays we expect the event to be published to
   * @returns A set of relays the event was published to
   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays
   * @example
   * ```typescript
   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);
   * const publishedToRelays = await relaySet.publish(event);
   * // publishedToRelays can contain relay1, relay2, both, or none
   * // depending on which relays the event was successfully published to
   * if (publishedToRelays.size > 0) {
   *   console.log("Event published to at least one relay");
   * }
   * ```
   */
  async publish(event, timeoutMs, requiredRelayCount = 1) {
    const publishedToRelays = /* @__PURE__ */ new Set();
    const errors = /* @__PURE__ */ new Map();
    const isEphemeral2 = event.isEphemeral();
    event.publishStatus = "pending";
    const relayPublishedHandler = (relay) => {
      publishedToRelays.add(relay);
    };
    event.on("relay:published", relayPublishedHandler);
    try {
      const promises = Array.from(this.relays).map((relay) => {
        return new Promise((resolve) => {
          const timeoutId = timeoutMs ? setTimeout(() => {
            if (!publishedToRelays.has(relay)) {
              errors.set(
                relay,
                new Error(`Publish timeout after ${timeoutMs}ms`)
              );
              resolve(false);
            }
          }, timeoutMs) : null;
          relay.publish(event, timeoutMs).then((success) => {
            if (timeoutId) clearTimeout(timeoutId);
            if (success) {
              publishedToRelays.add(relay);
              resolve(true);
            } else {
              resolve(false);
            }
          }).catch((err) => {
            if (timeoutId) clearTimeout(timeoutId);
            if (!isEphemeral2) {
              errors.set(relay, err);
            }
            resolve(false);
          });
        });
      });
      await Promise.all(promises);
      if (publishedToRelays.size < requiredRelayCount) {
        if (!isEphemeral2) {
          const error = new NDKPublishError(
            "Not enough relays received the event (" + publishedToRelays.size + " published, " + requiredRelayCount + " required)",
            errors,
            publishedToRelays,
            this
          );
          event.publishStatus = "error";
          event.publishError = error;
          this.ndk?.emit("event:publish-failed", event, error, this.relayUrls);
          throw error;
        }
      } else {
        event.publishStatus = "success";
        event.emit("published", { relaySet: this, publishedToRelays });
      }
      return publishedToRelays;
    } finally {
      event.off("relay:published", relayPublishedHandler);
    }
  }
  get size() {
    return this.relays.size;
  }
};

// src/relay/sets/calculate.ts
var d = createDebug("ndk:outbox:calculate");
async function calculateRelaySetFromEvent(ndk, event, requiredRelayCount) {
  const relays = /* @__PURE__ */ new Set();
  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);
  if (authorWriteRelays) {
    authorWriteRelays.forEach((relayUrl) => {
      const relay = ndk.pool?.getRelay(relayUrl);
      if (relay) relays.add(relay);
    });
  }
  let relayHints = event.tags.filter((tag) => ["a", "e"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith("wss://")).filter((url) => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }).map((url) => normalizeRelayUrl(url));
  relayHints = Array.from(new Set(relayHints)).slice(0, 5);
  relayHints.forEach((relayUrl) => {
    const relay = ndk.pool?.getRelay(relayUrl, true, true);
    if (relay) {
      d("Adding relay hint %s", relayUrl);
      relays.add(relay);
    }
  });
  const pTags = event.getMatchingTags("p").map((tag) => tag[1]);
  if (pTags.length < 5) {
    const pTaggedRelays = Array.from(
      chooseRelayCombinationForPubkeys(ndk, pTags, "read", {
        preferredRelays: new Set(authorWriteRelays)
      }).keys()
    );
    pTaggedRelays.forEach((relayUrl) => {
      const relay = ndk.pool?.getRelay(relayUrl, false, true);
      if (relay) {
        d("Adding p-tagged relay %s", relayUrl);
        relays.add(relay);
      }
    });
  } else {
    d("Too many p-tags to consider %d", pTags.length);
  }
  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));
  if (requiredRelayCount && relays.size < requiredRelayCount) {
    const explicitRelays = ndk.explicitRelayUrls?.filter((url) => !Array.from(relays).some((r) => r.url === url)).slice(0, requiredRelayCount - relays.size);
    explicitRelays?.forEach((url) => {
      const relay = ndk.pool?.getRelay(url, false, true);
      if (relay) {
        d("Adding explicit relay %s", url);
        relays.add(relay);
      }
    });
  }
  return new NDKRelaySet(relays, ndk);
}
function calculateRelaySetsFromFilter(ndk, filters, pool) {
  const result = /* @__PURE__ */ new Map();
  const authors = /* @__PURE__ */ new Set();
  filters.forEach((filter) => {
    if (filter.authors) {
      filter.authors.forEach((author) => authors.add(author));
    }
  });
  if (authors.size > 0) {
    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));
    for (const relayUrl of authorToRelaysMap.keys()) {
      result.set(relayUrl, []);
    }
    for (const filter of filters) {
      if (filter.authors) {
        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {
          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(
            (author) => authors2.includes(author)
          );
          result.set(relayUrl, [
            ...result.get(relayUrl),
            {
              ...filter,
              // Overwrite authors sent to this relay with the authors that were
              // present in the filter and are also present in the relay
              authors: authorFilterAndRelayPubkeyIntersection
            }
          ]);
        }
      } else {
        for (const relayUrl of authorToRelaysMap.keys()) {
          result.set(relayUrl, [...result.get(relayUrl), filter]);
        }
      }
    }
  } else {
    if (ndk.explicitRelayUrls) {
      ndk.explicitRelayUrls.forEach((relayUrl) => {
        result.set(relayUrl, filters);
      });
    }
  }
  if (result.size === 0) {
    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {
      result.set(relay.url, filters);
    });
  }
  return result;
}
function calculateRelaySetsFromFilters(ndk, filters, pool) {
  const a = calculateRelaySetsFromFilter(ndk, filters, pool);
  return a;
}

// src/events/content-tagger.ts
import { nip19 } from "nostr-tools";
function mergeTags(tags1, tags2) {
  const tagMap = /* @__PURE__ */ new Map();
  const generateKey = (tag) => tag.join(",");
  const isContained = (smaller, larger) => {
    return smaller.every((value, index) => value === larger[index]);
  };
  const processTag = (tag) => {
    for (const [key, existingTag] of tagMap) {
      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {
        if (tag.length >= existingTag.length) {
          tagMap.set(key, tag);
        }
        return;
      }
    }
    tagMap.set(generateKey(tag), tag);
  };
  tags1.concat(tags2).forEach(processTag);
  return Array.from(tagMap.values());
}
var hashtagRegex = /(?<=\s|^)(#[^\s!@#$%^&*()=+./,[{\]};:'"?><]+)/g;
function generateHashtags(content) {
  const hashtags = content.match(hashtagRegex);
  const tagIds = /* @__PURE__ */ new Set();
  const tag = /* @__PURE__ */ new Set();
  if (hashtags) {
    for (const hashtag of hashtags) {
      if (tagIds.has(hashtag.slice(1))) continue;
      tag.add(hashtag.slice(1));
      tagIds.add(hashtag.slice(1));
    }
  }
  return Array.from(tag);
}
async function generateContentTags(content, tags = []) {
  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;
  const promises = [];
  const addTagIfNew = (t) => {
    if (!tags.find((t2) => ["q", t[0]].includes(t2[0]) && t2[1] === t[1])) {
      tags.push(t);
    }
  };
  content = content.replace(tagRegex, (tag) => {
    try {
      const entity = tag.split(/(@|nostr:)/)[2];
      const { type, data } = nip19.decode(entity);
      let t;
      switch (type) {
        case "npub":
          t = ["p", data];
          break;
        case "nprofile":
          t = ["p", data.pubkey];
          break;
        case "note":
          promises.push(
            new Promise(async (resolve) => {
              addTagIfNew(["q", data, await maybeGetEventRelayUrl(entity)]);
              resolve();
            })
          );
          break;
        case "nevent":
          promises.push(
            new Promise(async (resolve) => {
              const { id, author } = data;
              let { relays } = data;
              if (!relays || relays.length === 0) {
                relays = [await maybeGetEventRelayUrl(entity)];
              }
              addTagIfNew(["q", id, relays[0]]);
              if (author) addTagIfNew(["p", author]);
              resolve();
            })
          );
          break;
        case "naddr":
          promises.push(
            new Promise(async (resolve) => {
              const id = [data.kind, data.pubkey, data.identifier].join(":");
              let relays = data.relays ?? [];
              if (relays.length === 0) {
                relays = [await maybeGetEventRelayUrl(entity)];
              }
              addTagIfNew(["q", id, relays[0]]);
              addTagIfNew(["p", data.pubkey]);
              resolve();
            })
          );
          break;
        default:
          return tag;
      }
      if (t) addTagIfNew(t);
      return `nostr:${entity}`;
    } catch (_error) {
      return tag;
    }
  });
  await Promise.all(promises);
  const newTags = generateHashtags(content).map((hashtag) => ["t", hashtag]);
  tags = mergeTags(tags, newTags);
  return { content, tags };
}
async function maybeGetEventRelayUrl(_nip19Id) {
  return "";
}

// src/events/encryption.ts
async function encrypt(recipient, signer, scheme = "nip44") {
  let encrypted;
  if (!this.ndk) throw new Error("No NDK instance found!");
  let currentSigner = signer;
  if (!currentSigner) {
    this.ndk.assertSigner();
    currentSigner = this.ndk.signer;
  }
  if (!currentSigner) throw new Error("no NDK signer");
  const currentRecipient = recipient || (() => {
    const pTags = this.getMatchingTags("p");
    if (pTags.length !== 1) {
      throw new Error(
        "No recipient could be determined and no explicit recipient was provided"
      );
    }
    return this.ndk.getUser({ pubkey: pTags[0][1] });
  })();
  if (scheme === "nip44" && await isEncryptionEnabled(currentSigner, "nip44")) {
    encrypted = await currentSigner.encrypt(
      currentRecipient,
      this.content,
      "nip44"
    );
  }
  if ((!encrypted || scheme === "nip04") && await isEncryptionEnabled(currentSigner, "nip04")) {
    encrypted = await currentSigner.encrypt(
      currentRecipient,
      this.content,
      "nip04"
    );
  }
  if (!encrypted) throw new Error("Failed to encrypt event.");
  this.content = encrypted;
}
async function decrypt(sender, signer, scheme) {
  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {
    let cachedEvent = null;
    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === "function") {
      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);
    }
    if (cachedEvent) {
      this.content = cachedEvent.content;
      return;
    }
  }
  let decrypted;
  if (!this.ndk) throw new Error("No NDK instance found!");
  let currentSigner = signer;
  if (!currentSigner) {
    this.ndk.assertSigner();
    currentSigner = this.ndk.signer;
  }
  if (!currentSigner) throw new Error("no NDK signer");
  const currentSender = sender || this.author;
  if (!currentSender) throw new Error("No sender provided and no author available");
  const currentScheme = scheme || (this.content.match(/\\?iv=/) ? "nip04" : "nip44");
  if ((currentScheme === "nip04" || this.kind === 4) && await isEncryptionEnabled(currentSigner, "nip04") && this.content.search("\\?iv=")) {
    decrypted = await currentSigner.decrypt(currentSender, this.content, "nip04");
  }
  if (!decrypted && currentScheme === "nip44" && await isEncryptionEnabled(currentSigner, "nip44")) {
    decrypted = await currentSigner.decrypt(currentSender, this.content, "nip44");
  }
  if (!decrypted) throw new Error("Failed to decrypt event.");
  this.content = decrypted;
  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {
    this.ndk.cacheAdapter.addDecryptedEvent(this);
  }
}
async function isEncryptionEnabled(signer, scheme) {
  if (!signer.encryptionEnabled) return false;
  if (!scheme) return true;
  return Boolean(await signer.encryptionEnabled(scheme));
}

// src/thread/index.ts
function eventHasETagMarkers(event) {
  for (const tag of event.tags) {
    if (tag[0] === "e" && (tag[3] ?? "").length > 0) return true;
  }
  return false;
}
function getRootTag(event, searchTag) {
  searchTag ??= event.tagType();
  const rootEventTag = event.tags.find(isTagRootTag);
  if (!rootEventTag) {
    if (eventHasETagMarkers(event)) return;
    const matchingTags = event.getMatchingTags(searchTag);
    if (matchingTags.length < 3) return matchingTags[0];
  }
  return rootEventTag;
}
var nip22RootTags = /* @__PURE__ */ new Set(["A", "E", "I"]);
var nip22ReplyTags = /* @__PURE__ */ new Set(["a", "e", "i"]);
function getReplyTag(event, searchTag) {
  if (event.kind === 1111 /* GenericReply */) {
    let replyTag2;
    for (const tag of event.tags) {
      if (nip22RootTags.has(tag[0])) replyTag2 = tag;
      else if (nip22ReplyTags.has(tag[0])) {
        replyTag2 = tag;
        break;
      }
    }
    return replyTag2;
  }
  searchTag ??= event.tagType();
  let hasMarkers = false;
  let replyTag;
  for (const tag of event.tags) {
    if (tag[0] !== searchTag) continue;
    if ((tag[3] ?? "").length > 0) hasMarkers = true;
    if (hasMarkers && tag[3] === "reply") return tag;
    if (hasMarkers && tag[3] === "root") replyTag = tag;
    if (!hasMarkers) replyTag = tag;
  }
  return replyTag;
}
function isTagRootTag(tag) {
  return tag[0] === "E" || tag[3] === "root";
}

// src/events/fetch-tagged-event.ts
async function fetchTaggedEvent(tag, marker) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const t = this.getMatchingTags(tag, marker);
  if (t.length === 0) return void 0;
  const [_, id, hint] = t[0];
  let relay = hint !== "" ? this.ndk.pool.getRelay(hint) : void 0;
  const event = await this.ndk.fetchEvent(id, {}, relay);
  return event;
}
async function fetchRootEvent(subOpts) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const rootTag = getRootTag(this);
  if (!rootTag) return void 0;
  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);
}
async function fetchReplyEvent(subOpts) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const replyTag = getReplyTag(this);
  if (!replyTag) return void 0;
  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);
}

// src/events/kind.ts
function isReplaceable() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;
}
function isEphemeral() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return this.kind >= 2e4 && this.kind < 3e4;
}
function isParamReplaceable() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}

// src/events/nip19.ts
import { nip19 as nip192 } from "nostr-tools";
var DEFAULT_RELAY_COUNT = 2;
function encode(maxRelayCount = DEFAULT_RELAY_COUNT) {
  let relays = [];
  if (this.onRelays.length > 0) {
    relays = this.onRelays.map((relay) => relay.url);
  } else if (this.relay) {
    relays = [this.relay.url];
  }
  if (relays.length > maxRelayCount) {
    relays = relays.slice(0, maxRelayCount);
  }
  if (this.isParamReplaceable()) {
    return nip192.naddrEncode({
      kind: this.kind,
      pubkey: this.pubkey,
      identifier: this.replaceableDTag(),
      relays
    });
  }
  if (relays.length > 0) {
    return nip192.neventEncode({
      id: this.tagId(),
      relays,
      author: this.pubkey
    });
  }
  return nip192.noteEncode(this.tagId());
}

// src/events/repost.ts
async function repost(publish = true, signer) {
  if (!signer && publish) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  const e = new NDKEvent(this.ndk, {
    kind: getKind(this)
  });
  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());
  e.tag(this);
  if (this.kind !== 1 /* Text */) {
    e.tags.push(["k", `${this.kind}`]);
  }
  if (signer) await e.sign(signer);
  if (publish) await e.publish();
  return e;
}
function getKind(event) {
  if (event.kind === 1) {
    return 6 /* Repost */;
  }
  return 16 /* GenericRepost */;
}

// src/events/serializer.ts
function serialize(includeSig = false, includeId = false) {
  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];
  if (includeSig) payload.push(this.sig);
  if (includeId) payload.push(this.id);
  return JSON.stringify(payload);
}
function deserialize(serializedEvent) {
  const eventArray = JSON.parse(serializedEvent);
  const ret = {
    pubkey: eventArray[1],
    created_at: eventArray[2],
    kind: eventArray[3],
    tags: eventArray[4],
    content: eventArray[5]
  };
  if (eventArray.length >= 7) {
    const first = eventArray[6];
    const second = eventArray[7];
    if (first && first.length === 128) {
      ret.sig = first;
      if (second && second.length === 64) {
        ret.id = second;
      }
    } else if (first && first.length === 64) {
      ret.id = first;
      if (second && second.length === 128) {
        ret.sig = second;
      }
    }
  }
  return ret;
}

// src/events/validation.ts
import { schnorr } from "@noble/curves/secp256k1";
import { sha256 } from "@noble/hashes/sha256";
import { bytesToHex } from "@noble/hashes/utils";
import { LRUCache } from "typescript-lru-cache";

// src/events/signature.ts
var worker;
var processingQueue = {};
function signatureVerificationInit(w) {
  worker = w;
  worker.onmessage = (msg) => {
    const [eventId, result] = msg.data;
    const record = processingQueue[eventId];
    if (!record) {
      console.error("No record found for event", eventId);
      return;
    }
    delete processingQueue[eventId];
    for (const resolve of record.resolves) {
      resolve(result);
    }
  };
}
async function verifySignatureAsync(event, _persist, relay) {
  const ndkInstance = event.ndk;
  const start = Date.now();
  let result;
  if (ndkInstance.signatureVerificationFunction) {
    console.log("[NDK-CORE] Using custom signature verification function async");
    result = await ndkInstance.signatureVerificationFunction(event);
    console.log("Custom signature verification result", event.id, { result });
  } else {
    console.log("Using worker-based signature verification async");
    result = await new Promise((resolve) => {
      const serialized = event.serialize();
      let enqueue = false;
      if (!processingQueue[event.id]) {
        processingQueue[event.id] = { event, resolves: [], relay };
        enqueue = true;
      }
      processingQueue[event.id].resolves.push(resolve);
      if (!enqueue) return;
      worker?.postMessage({
        serialized,
        id: event.id,
        sig: event.sig,
        pubkey: event.pubkey
      });
    });
  }
  ndkInstance.signatureVerificationTimeMs += Date.now() - start;
  return result;
}

// src/events/validation.ts
var PUBKEY_REGEX = /^[a-f0-9]{64}$/;
function validate() {
  if (typeof this.kind !== "number") return false;
  if (typeof this.content !== "string") return false;
  if (typeof this.created_at !== "number") return false;
  if (typeof this.pubkey !== "string") return false;
  if (!this.pubkey.match(PUBKEY_REGEX)) return false;
  if (!Array.isArray(this.tags)) return false;
  for (let i = 0; i < this.tags.length; i++) {
    const tag = this.tags[i];
    if (!Array.isArray(tag)) return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object") return false;
    }
  }
  return true;
}
var verifiedSignatures = new LRUCache({
  maxSize: 1e3,
  entryExpirationTimeInMS: 6e4
});
function verifySignature(persist) {
  if (typeof this.signatureVerified === "boolean") return this.signatureVerified;
  const prevVerification = verifiedSignatures.get(this.id);
  if (prevVerification !== null) {
    this.signatureVerified = !!prevVerification;
    return this.signatureVerified;
  }
  try {
    if (this.ndk?.asyncSigVerification) {
      verifySignatureAsync(this, persist, this.relay).then((result) => {
        if (persist) {
          this.signatureVerified = result;
          if (result) verifiedSignatures.set(this.id, this.sig);
        }
        if (!result) {
          if (this.relay) {
            this.ndk?.reportInvalidSignature(this, this.relay);
          } else {
            this.ndk?.reportInvalidSignature(this);
          }
          verifiedSignatures.set(this.id, false);
        }
      }).catch((err) => {
        console.error("signature verification error", this.id, err);
      });
    } else {
      const hash = sha256(new TextEncoder().encode(this.serialize()));
      const res = schnorr.verify(this.sig, hash, this.pubkey);
      if (res) verifiedSignatures.set(this.id, this.sig);
      else verifiedSignatures.set(this.id, false);
      this.signatureVerified = res;
      return res;
    }
  } catch (_err) {
    this.signatureVerified = false;
    return false;
  }
}
function getEventHash() {
  return getEventHashFromSerializedEvent(this.serialize());
}
function getEventHashFromSerializedEvent(serializedEvent) {
  const eventHash = sha256(new TextEncoder().encode(serializedEvent));
  return bytesToHex(eventHash);
}

// src/events/index.ts
var skipClientTagOnKinds = /* @__PURE__ */ new Set([
  0 /* Metadata */,
  4 /* EncryptedDirectMessage */,
  1059 /* GiftWrap */,
  13 /* GiftWrapSeal */,
  3 /* Contacts */,
  9734 /* ZapRequest */,
  5 /* EventDeletion */
]);
var NDKEvent = class _NDKEvent extends EventEmitter {
  ndk;
  created_at;
  content = "";
  tags = [];
  kind;
  id = "";
  sig;
  pubkey = "";
  signatureVerified;
  _author = void 0;
  /**
   * The relay that this event was first received from.
   */
  relay;
  /**
   * The relays that this event was received from and/or successfully published to.
   */
  get onRelays() {
    let res = [];
    if (!this.ndk) {
      if (this.relay) res.push(this.relay);
    } else {
      res = this.ndk.subManager.seenEvents.get(this.id) || [];
    }
    return res;
  }
  /**
   * The status of the publish operation.
   */
  publishStatus = "success";
  publishError;
  constructor(ndk, event) {
    super();
    this.ndk = ndk;
    this.created_at = event?.created_at;
    this.content = event?.content || "";
    this.tags = event?.tags || [];
    this.id = event?.id || "";
    this.sig = event?.sig;
    this.pubkey = event?.pubkey || "";
    this.kind = event?.kind;
    if (event instanceof _NDKEvent) {
      if (this.relay) {
        this.relay = event.relay;
        this.ndk?.subManager.seenEvent(event.id, this.relay);
      }
      this.publishStatus = event.publishStatus;
      this.publishError = event.publishError;
    }
  }
  /**
   * Deserialize an NDKEvent from a serialized payload.
   * @param ndk
   * @param event
   * @returns
   */
  static deserialize(ndk, event) {
    return new _NDKEvent(ndk, deserialize(event));
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(user) {
    this.pubkey = user.pubkey;
    this._author = user;
    this._author.ndk ??= this.ndk;
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    if (this._author) return this._author;
    if (!this.ndk) throw new Error("No NDK instance found");
    const user = this.ndk.getUser({ pubkey: this.pubkey });
    this._author = user;
    return user;
  }
  /**
   * NIP-73 tagging of external entities
   * @param entity to be tagged
   * @param type of the entity
   * @param markerUrl to be used as the marker URL
   *
   * @example
   * ```typescript
   * event.tagExternal("https://example.com/article/123#nostr", "url");
   * event.tags => [["i", "https://example.com/123"], ["k", "https://example.com"]]
   * ```
   *
   * @example tag a podcast:item:guid
   * ```typescript
   * event.tagExternal("e32b4890-b9ea-4aef-a0bf-54b787833dc5", "podcast:item:guid");
   * event.tags => [["i", "podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5"], ["k", "podcast:item:guid"]]
   * ```
   *
   * @see https://github.com/nostr-protocol/nips/blob/master/73.md
   */
  tagExternal(entity, type, markerUrl) {
    const iTag = ["i"];
    const kTag = ["k"];
    switch (type) {
      case "url": {
        const url = new URL(entity);
        url.hash = "";
        iTag.push(url.toString());
        kTag.push(`${url.protocol}//${url.host}`);
        break;
      }
      case "hashtag":
        iTag.push(`#${entity.toLowerCase()}`);
        kTag.push("#");
        break;
      case "geohash":
        iTag.push(`geo:${entity.toLowerCase()}`);
        kTag.push("geo");
        break;
      case "isbn":
        iTag.push(`isbn:${entity.replace(/-/g, "")}`);
        kTag.push("isbn");
        break;
      case "podcast:guid":
        iTag.push(`podcast:guid:${entity}`);
        kTag.push("podcast:guid");
        break;
      case "podcast:item:guid":
        iTag.push(`podcast:item:guid:${entity}`);
        kTag.push("podcast:item:guid");
        break;
      case "podcast:publisher:guid":
        iTag.push(`podcast:publisher:guid:${entity}`);
        kTag.push("podcast:publisher:guid");
        break;
      case "isan":
        iTag.push(`isan:${entity.split("-").slice(0, 4).join("-")}`);
        kTag.push("isan");
        break;
      case "doi":
        iTag.push(`doi:${entity.toLowerCase()}`);
        kTag.push("doi");
        break;
      default:
        throw new Error(`Unsupported NIP-73 entity type: ${type}`);
    }
    if (markerUrl) {
      iTag.push(markerUrl);
    }
    this.tags.push(iTag);
    this.tags.push(kTag);
  }
  /**
   * Tag a user with an optional marker.
   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.
   * @param marker The marker to use in the tag.
   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.
   * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag.
   * @example
   * ```typescript
   * reply.tag(opEvent, "reply");
   * // reply.tags => [["e", <id>, <relay>, "reply"]]
   * ```
   */
  tag(target, marker, skipAuthorTag, forceTag) {
    let tags = [];
    const isNDKUser = target.fetchProfile !== void 0;
    if (isNDKUser) {
      forceTag ??= "p";
      const tag = [forceTag, target.pubkey];
      if (marker) tag.push(...["", marker]);
      tags.push(tag);
    } else if (target instanceof _NDKEvent) {
      const event = target;
      skipAuthorTag ??= event?.pubkey === this.pubkey;
      tags = event.referenceTags(marker, skipAuthorTag, forceTag);
      for (const pTag of event.getMatchingTags("p")) {
        if (pTag[1] === this.pubkey) continue;
        if (this.tags.find((t) => t[0] === "p" && t[1] === pTag[1])) continue;
        this.tags.push(["p", pTag[1]]);
      }
    } else if (Array.isArray(target)) {
      tags = [target];
    } else {
      throw new Error("Invalid argument", target);
    }
    this.tags = mergeTags(this.tags, tags);
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(pubkey) {
    if (!pubkey && this.pubkey === "") {
      const user = await this.ndk?.signer?.user();
      this.pubkey = user?.pubkey || "";
    }
    if (!this.created_at) {
      this.created_at = Math.floor(Date.now() / 1e3);
    }
    const { content, tags } = await this.generateTags();
    this.content = content || "";
    this.tags = tags;
    try {
      this.id = this.getEventHash();
    } catch (_e) {
    }
    return this.rawEvent();
  }
  serialize = serialize.bind(this);
  getEventHash = getEventHash.bind(this);
  validate = validate.bind(this);
  verifySignature = verifySignature.bind(this);
  /**
   * Is this event replaceable (whether parameterized or not)?
   *
   * This will return true for kind 0, 3, 10k-20k and 30k-40k
   */
  isReplaceable = isReplaceable.bind(this);
  isEphemeral = isEphemeral.bind(this);
  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;
  /**
   * Is this event parameterized replaceable?
   *
   * This will return true for kind 30k-40k
   */
  isParamReplaceable = isParamReplaceable.bind(this);
  /**
   * Encodes a bech32 id.
   *
   * @param relays {string[]} The relays to encode in the id
   * @returns {string} - Encoded naddr, note or nevent.
   */
  encode = encode.bind(this);
  encrypt = encrypt.bind(this);
  decrypt = decrypt.bind(this);
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(tagName, marker) {
    const t = this.tags.filter((tag) => tag[0] === tagName);
    if (marker === void 0) return t;
    return t.filter((tag) => tag[3] === marker);
  }
  /**
   * Check if the event has a tag with the given name
   * @param tagName
   * @param marker
   * @returns
   */
  hasTag(tagName, marker) {
    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(tagName, marker) {
    const tags = this.getMatchingTags(tagName, marker);
    if (tags.length === 0) return void 0;
    return tags[0][1];
  }
  /**
   * Gets the NIP-31 "alt" tag of the event.
   */
  get alt() {
    return this.tagValue("alt");
  }
  /**
   * Sets the NIP-31 "alt" tag of the event. Use this to set an alt tag so
   * clients that don't handle a particular event kind can display something
   * useful for users.
   */
  set alt(alt) {
    this.removeTag("alt");
    if (alt) this.tags.push(["alt", alt]);
  }
  /**
   * Gets the NIP-33 "d" tag of the event.
   */
  get dTag() {
    return this.tagValue("d");
  }
  /**
   * Sets the NIP-33 "d" tag of the event.
   */
  set dTag(value) {
    this.removeTag("d");
    if (value) this.tags.push(["d", value]);
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name(s) to search for and remove
   * @param marker Optional marker to check for too
   *
   * @example
   * Remove a tags with a "defer" marker
   * ```typescript
   * event.tags = [
   *   ["a", "....", "defer"],
   *   ["a", "....", "no-defer"],
   * ]
   *
   * event.removeTag("a", "defer");
   *
   * // event.tags => [["a", "....", "no-defer"]]
   *
   * @returns {void}
   */
  removeTag(tagName, marker) {
    const tagNames = Array.isArray(tagName) ? tagName : [tagName];
    this.tags = this.tags.filter((tag) => {
      const include = tagNames.includes(tag[0]);
      const hasMarker = marker ? tag[3] === marker : true;
      return !(include && hasMarker);
    });
  }
  /**
   * Replace a tag with a new value. If not found, it will be added.
   * @param tag The tag to replace.
   * @param value The new value for the tag.
   */
  replaceTag(tag) {
    this.removeTag(tag[0]);
    this.tags.push(tag);
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(signer) {
    if (!signer) {
      this.ndk?.assertSigner();
      signer = this.ndk?.signer;
    } else {
      this.author = await signer.user();
    }
    const nostrEvent = await this.toNostrEvent();
    this.sig = await signer.sign(nostrEvent);
    return this.sig;
  }
  /**
   *
   * @param relaySet
   * @param timeoutMs
   * @param requiredRelayCount
   * @returns
   */
  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {
    this.id = "";
    this.created_at = Math.floor(Date.now() / 1e3);
    this.sig = "";
    return this.publish(relaySet, timeoutMs, requiredRelayCount);
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @param timeoutM {number} The timeout for the publish operation in milliseconds.
   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    if (!requiredRelayCount) requiredRelayCount = 1;
    if (!this.sig) await this.sign();
    if (!this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    if (!relaySet || relaySet.size === 0) {
      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this, requiredRelayCount);
    }
    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {
      const eTags = this.getMatchingTags("e").map((tag) => tag[1]);
      this.ndk.cacheAdapter.deleteEventIds(eTags);
    }
    const rawEvent = this.rawEvent();
    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {
      try {
        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);
      } catch (e) {
        console.error("Error adding unpublished event to cache", e);
      }
    }
    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {
      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map((tag) => tag[1]));
    }
    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);
    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);
    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));
    return relays;
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  async generateTags() {
    let tags = [];
    const g = await generateContentTags(this.content, this.tags);
    const content = g.content;
    tags = g.tags;
    if (this.kind && this.isParamReplaceable()) {
      const dTag = this.getMatchingTags("d")[0];
      if (!dTag) {
        const title = this.tagValue("title");
        const randLength = title ? 6 : 16;
        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join("");
        if (title && title.length > 0) {
          str = `${title.replace(/[^a-z0-9]+/gi, "-").replace(/^-|-$/g, "")}-${str}`;
        }
        tags.push(["d", str]);
      }
    }
    if (this.shouldAddClientTag) {
      const clientTag = ["client", this.ndk?.clientName ?? ""];
      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);
      tags.push(clientTag);
    } else if (this.shouldStripClientTag) {
      tags = tags.filter((tag) => tag[0] !== "client");
    }
    return { content: content || "", tags };
  }
  get shouldAddClientTag() {
    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;
    if (skipClientTagOnKinds.has(this.kind)) return false;
    if (this.isEphemeral()) return false;
    if (this.isReplaceable() && !this.isParamReplaceable()) return false;
    if (this.isDvm()) return false;
    if (this.hasTag("client")) return false;
    return true;
  }
  get shouldStripClientTag() {
    return skipClientTagOnKinds.has(this.kind);
  }
  muted() {
    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);
    if (authorMutedEntry && authorMutedEntry === "p") return "author";
    const eventTagReference = this.tagReference();
    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);
    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return "event";
    return null;
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   *
   * @deprecated Use `dTag` instead.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const dTag = this.getMatchingTags("d")[0];
      const dTagId = dTag ? dTag[1] : "";
      return dTagId;
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Provides a deduplication key for the event.
   *
   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
   * For all other kinds this will be the event id
   */
  deduplicationKey() {
    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {
      return `${this.kind}:${this.pubkey}`;
    }
    return this.tagId();
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    if (this.isParamReplaceable()) {
      return this.tagAddress();
    }
    return this.id;
  }
  /**
   * Returns a stable reference value for a replaceable event.
   *
   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.
   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.
   *
   * @returns {string} A stable reference value for replaceable events
   */
  tagAddress() {
    if (this.isParamReplaceable()) {
      const dTagId = this.dTag ?? "";
      return `${this.kind}:${this.pubkey}:${dTagId}`;
    }
    if (this.isReplaceable()) {
      return `${this.kind}:${this.pubkey}:`;
    }
    throw new Error("Event is not a replaceable event");
  }
  /**
   * Determines the type of tag that can be used to reference this event from another event.
   * @returns {string} The tag type
   * @example
   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   * event.tagType(); // "a"
   */
  tagType() {
    return this.isParamReplaceable() ? "a" : "e";
  }
  /**
   * Get the tag that can be used to reference this event from another event.
   *
   * Consider using referenceTags() instead (unless you have a good reason to use this)
   *
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference(marker) {
    let tag;
    if (this.isParamReplaceable()) {
      tag = ["a", this.tagAddress()];
    } else {
      tag = ["e", this.tagId()];
    }
    if (this.relay) {
      tag.push(this.relay.url);
    } else {
      tag.push("");
    }
    tag.push(marker ?? "");
    if (!this.isParamReplaceable()) {
      tag.push(this.pubkey);
    }
    return tag;
  }
  /**
   * Get the tags that can be used to reference this event from another event
   * @param marker The marker to use in the tag
   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event
   * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.referenceTags(); // [["e", "parent-id"]]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  referenceTags(marker, skipAuthorTag, forceTag) {
    let tags = [];
    if (this.isParamReplaceable()) {
      tags = [
        [forceTag ?? "a", this.tagAddress()],
        [forceTag ?? "e", this.id]
      ];
    } else {
      tags = [[forceTag ?? "e", this.id]];
    }
    tags = tags.map((tag) => {
      if (tag[0] === "e" || marker) {
        tag.push(this.relay?.url ?? "");
      } else if (this.relay?.url) {
        tag.push(this.relay?.url);
      }
      return tag;
    });
    tags.forEach((tag) => {
      if (tag[0] === "e") {
        tag.push(marker ?? "");
        tag.push(this.pubkey);
      } else if (marker) {
        tag.push(marker);
      }
    });
    tags = [...tags, ...this.getMatchingTags("h")];
    if (!skipAuthorTag) tags.push(...this.author.referenceTags());
    return tags;
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    if (this.isParamReplaceable()) {
      return { "#a": [this.tagId()] };
    }
    return { "#e": [this.tagId()] };
  }
  nip22Filter() {
    if (this.isParamReplaceable()) {
      return { "#A": [this.tagId()] };
    }
    return { "#E": [this.tagId()] };
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @param publish Whether to publish the deletion event automatically
   * @returns The deletion event
   */
  async delete(reason, publish = true) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const e = new _NDKEvent(this.ndk, {
      kind: 5 /* EventDeletion */,
      content: reason || ""
    });
    e.tag(this, void 0, true);
    e.tags.push(["k", this.kind?.toString()]);
    if (publish) {
      this.emit("deleted");
      await e.publish();
    }
    return e;
  }
  /**
   * Establishes whether this is a NIP-70-protectede event.
   * @@satisfies NIP-70
   */
  set isProtected(val) {
    this.removeTag("-");
    if (val) this.tags.push(["-"]);
  }
  /**
   * Whether this is a NIP-70-protected event.
   * @@satisfies NIP-70
   */
  get isProtected() {
    return this.hasTag("-");
  }
  /**
   * Fetch an event tagged with the given tag following relay hints if provided.
   * @param tag The tag to search for
   * @param marker The marker to use in the tag (e.g. "root")
   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event
   * * @example
   * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
   * const originalEvent = await replyEvent.fetchTaggedEvent("e", "reply");
   * console.log(replyEvent.encode() + " is a reply to event " + originalEvent?.encode());
   */
  fetchTaggedEvent = fetchTaggedEvent.bind(this);
  /**
   * Fetch the root event of the current event.
   * @returns The fetched root event or null if no event was found
   * @example
   * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
   * const rootEvent = await replyEvent.fetchRootEvent();
   * console.log(replyEvent.encode() + " is a reply in the thread " + rootEvent?.encode());
   */
  fetchRootEvent = fetchRootEvent.bind(this);
  /**
   * Fetch the event the current event is replying to.
   * @returns The fetched reply event or null if no event was found
   */
  fetchReplyEvent = fetchReplyEvent.bind(this);
  /**
   * NIP-18 reposting event.
   *
   * @param publish Whether to publish the reposted event automatically @default true
   * @param signer The signer to use for signing the reposted event
   * @returns The reposted event
   *
   * @function
   */
  repost = repost.bind(this);
  /**
   * React to an existing event
   *
   * @param content The content of the reaction
   */
  async react(content, publish = true) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const e = new _NDKEvent(this.ndk, {
      kind: 7 /* Reaction */,
      content
    });
    e.tag(this);
    if (this.kind !== 1 /* Text */) {
      e.tags.push(["k", `${this.kind}`]);
    }
    if (publish) await e.publish();
    return e;
  }
  /**
   * Checks whether the event is valid per underlying NIPs.
   *
   * This method is meant to be overridden by subclasses that implement specific NIPs
   * to allow the enforcement of NIP-specific validation rules.
   *
   * Otherwise, it will only check for basic event properties.
   *
   */
  get isValid() {
    return this.validate();
  }
  get inspect() {
    return JSON.stringify(this.rawEvent(), null, 4);
  }
  /**
   * Dump the event to console for debugging purposes.
   * Prints a JSON stringified version of rawEvent() with indentation
   * and also lists all relay URLs for onRelays.
   */
  dump() {
    console.debug(JSON.stringify(this.rawEvent(), null, 4));
    console.debug("Event on relays:", this.onRelays.map((relay) => relay.url).join(", "));
  }
  /**
   * Creates a reply event for the current event.
   *
   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).
   * This function does not have side-effects; it will just return an event with the appropriate tags
   * to generate the reply event; the caller is responsible for publishing the event.
   *
   * @param forceNip22 - Optional flag to force NIP-22 style replies (kind 1111) regardless of the original event's kind
   */
  reply(forceNip22) {
    const reply = new _NDKEvent(this.ndk);
    if (this.kind === 1 && !forceNip22) {
      reply.kind = 1;
      const opHasETag = this.hasTag("e");
      if (opHasETag) {
        reply.tags = [
          ...reply.tags,
          ...this.getMatchingTags("e"),
          ...this.getMatchingTags("p"),
          ...this.getMatchingTags("a"),
          ...this.referenceTags("reply")
        ];
      } else {
        reply.tag(this, "root");
      }
    } else {
      reply.kind = 1111 /* GenericReply */;
      const carryOverTags = ["A", "E", "I", "P"];
      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));
      if (rootTags.length > 0) {
        const rootKind = this.tagValue("K");
        reply.tags.push(...rootTags);
        if (rootKind) reply.tags.push(["K", rootKind]);
        const [type, id, _, ...extra] = this.tagReference();
        const tag = [type, id, ...extra];
        reply.tags.push(tag);
      } else {
        const [type, id, _, relayHint] = this.tagReference();
        const tag = [type, id, relayHint ?? ""];
        if (type === "e") tag.push(this.pubkey);
        reply.tags.push(tag);
        const uppercaseTag = [...tag];
        uppercaseTag[0] = uppercaseTag[0].toUpperCase();
        reply.tags.push(uppercaseTag);
        reply.tags.push(["K", this.kind?.toString()]);
        reply.tags.push(["P", this.pubkey]);
      }
      reply.tags.push(["k", this.kind?.toString()]);
      reply.tags.push(...this.getMatchingTags("p"));
      reply.tags.push(["p", this.pubkey]);
    }
    return reply;
  }
};
var untrackedUnpublishedEvents = /* @__PURE__ */ new Set([
  24133 /* NostrConnect */,
  13194 /* NostrWaletConnectInfo */,
  23194 /* NostrWalletConnectReq */,
  23195 /* NostrWalletConnectRes */
]);
function shouldTrackUnpublishedEvent(event) {
  return !untrackedUnpublishedEvents.has(event.kind);
}

// src/relay/connectivity.ts
var MAX_RECONNECT_ATTEMPTS = 5;
var FLAPPING_THRESHOLD_MS = 1e3;
var NDKRelayConnectivity = class {
  ndkRelay;
  ws;
  _status;
  timeoutMs;
  connectedAt;
  _connectionStats = {
    attempts: 0,
    success: 0,
    durations: []
  };
  debug;
  netDebug;
  connectTimeout;
  reconnectTimeout;
  ndk;
  openSubs = /* @__PURE__ */ new Map();
  openCountRequests = /* @__PURE__ */ new Map();
  openEventPublishes = /* @__PURE__ */ new Map();
  serial = 0;
  baseEoseTimeout = 4400;
  constructor(ndkRelay, ndk) {
    this.ndkRelay = ndkRelay;
    this._status = 1 /* DISCONNECTED */;
    const rand = Math.floor(Math.random() * 1e3);
    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);
    this.ndk = ndk;
  }
  /**
   * Connects to the NDK relay and handles the connection lifecycle.
   *
   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.
   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,
   * and emits `connect` and `ready` events on the `ndkRelay` object.
   *
   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a
   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.
   *
   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.
   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.
   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.
   */
  async connect(timeoutMs, reconnect = true) {
    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */) {
      this.debug(
        "Relay requested to be connected but was in state %s or it had a reconnect timeout",
        this._status
      );
      return;
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    timeoutMs ??= this.timeoutMs;
    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;
    if (this.timeoutMs)
      this.connectTimeout = setTimeout(
        () => this.onConnectionError(reconnect),
        this.timeoutMs
      );
    try {
      this.updateConnectionStats.attempt();
      if (this._status === 1 /* DISCONNECTED */)
        this._status = 4 /* CONNECTING */;
      else this._status = 2 /* RECONNECTING */;
      this.ws = new WebSocket(this.ndkRelay.url);
      this.ws.onopen = this.onConnect.bind(this);
      this.ws.onclose = this.onDisconnect.bind(this);
      this.ws.onmessage = this.onMessage.bind(this);
      this.ws.onerror = this.onError.bind(this);
    } catch (e) {
      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);
      this._status = 1 /* DISCONNECTED */;
      if (reconnect) this.handleReconnection();
      else this.ndkRelay.emit("delayed-connect", 2 * 24 * 60 * 60 * 1e3);
      throw e;
    }
  }
  /**
   * Disconnects the WebSocket connection to the NDK relay.
   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,
   * attempts to close the WebSocket connection, and sets the status to
   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.
   */
  disconnect() {
    this._status = 0 /* DISCONNECTING */;
    try {
      this.ws?.close();
    } catch (e) {
      this.debug("Failed to disconnect", e);
      this._status = 1 /* DISCONNECTED */;
    }
  }
  /**
   * Handles the error that occurred when attempting to connect to the NDK relay.
   * If `reconnect` is `true`, this method will initiate a reconnection attempt.
   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,
   * indicating that a reconnection should be attempted after a delay.
   *
   * @param reconnect - Indicates whether a reconnection should be attempted.
   */
  onConnectionError(reconnect) {
    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);
    if (reconnect && !this.reconnectTimeout) {
      this.handleReconnection();
    }
  }
  /**
   * Handles the connection event when the WebSocket connection is established.
   * This method is called when the WebSocket connection is successfully opened.
   * It clears any existing connection and reconnection timeouts, updates the connection statistics,
   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.
   */
  onConnect() {
    this.netDebug?.("connected", this.ndkRelay);
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    this.updateConnectionStats.connected();
    this._status = 5 /* CONNECTED */;
    this.ndkRelay.emit("connect");
    this.ndkRelay.emit("ready");
  }
  /**
   * Handles the disconnection event when the WebSocket connection is closed.
   * This method is called when the WebSocket connection is successfully closed.
   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,
   * initiates a reconnection attempt if we didn't disconnect ourselves,
   * and emits a `disconnect` event on the `ndkRelay` object.
   */
  onDisconnect() {
    this.netDebug?.("disconnected", this.ndkRelay);
    this.updateConnectionStats.disconnected();
    if (this._status === 5 /* CONNECTED */) {
      this.handleReconnection();
    }
    this._status = 1 /* DISCONNECTED */;
    this.ndkRelay.emit("disconnect");
  }
  /**
   * Handles incoming messages from the NDK relay WebSocket connection.
   * This method is called whenever a message is received from the relay.
   * It parses the message data and dispatches the appropriate handling logic based on the message type.
   *
   * @param event - The MessageEvent containing the received message data.
   */
  onMessage(event) {
    this.netDebug?.(event.data, this.ndkRelay, "recv");
    try {
      const data = JSON.parse(event.data);
      const [cmd, id, ..._rest] = data;
      switch (cmd) {
        case "EVENT": {
          const so = this.openSubs.get(id);
          const event2 = data[2];
          if (!so) {
            this.debug(`Received event for unknown subscription ${id}`);
            return;
          }
          so.onevent(event2);
          return;
        }
        case "COUNT": {
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(id);
          if (!so) return;
          so.oneose(id);
          return;
        }
        case "OK": {
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          const firstEp = ep?.pop();
          if (!ep || !firstEp) {
            this.debug("Received OK for unknown event publish", id);
            return;
          }
          if (ok) firstEp.resolve(reason);
          else firstEp.reject(new Error(reason));
          if (ep.length === 0) {
            this.openEventPublishes.delete(id);
          } else {
            this.openEventPublishes.set(id, ep);
          }
          return;
        }
        case "CLOSED": {
          const so = this.openSubs.get(id);
          if (!so) return;
          so.onclosed(data[2]);
          return;
        }
        case "NOTICE":
          this.onNotice(data[1]);
          return;
        case "AUTH": {
          this.onAuthRequested(data[1]);
          return;
        }
      }
    } catch (error) {
      this.debug(
        `Error parsing message from ${this.ndkRelay.url}: ${error.message}`,
        error?.stack
      );
      return;
    }
  }
  /**
   * Handles an authentication request from the NDK relay.
   *
   * If an authentication policy is configured, it will be used to authenticate the connection.
   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.
   *
   * @param challenge - The authentication challenge provided by the NDK relay.
   */
  async onAuthRequested(challenge) {
    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;
    this.debug("Relay requested authentication", {
      havePolicy: !!authPolicy
    });
    if (this._status === 7 /* AUTHENTICATING */) {
      this.debug("Already authenticating, ignoring");
      return;
    }
    this._status = 6 /* AUTH_REQUESTED */;
    if (authPolicy) {
      if (this._status >= 5 /* CONNECTED */) {
        this._status = 7 /* AUTHENTICATING */;
        let res;
        try {
          res = await authPolicy(this.ndkRelay, challenge);
        } catch (e) {
          this.debug("Authentication policy threw an error", e);
          res = false;
        }
        this.debug("Authentication policy returned", !!res);
        if (res instanceof NDKEvent || res === true) {
          if (res instanceof NDKEvent) {
            await this.auth(res);
          }
          const authenticate = async () => {
            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {
              const event = new NDKEvent(this.ndk);
              event.kind = 22242 /* ClientAuth */;
              event.tags = [
                ["relay", this.ndkRelay.url],
                ["challenge", challenge]
              ];
              await event.sign();
              this.auth(event).then(() => {
                this._status = 8 /* AUTHENTICATED */;
                this.ndkRelay.emit("authed");
                this.debug("Authentication successful");
              }).catch((e) => {
                this._status = 6 /* AUTH_REQUESTED */;
                this.ndkRelay.emit("auth:failed", e);
                this.debug("Authentication failed", e);
              });
            } else {
              this.debug(
                "Authentication failed, it changed status, status is %d",
                this._status
              );
            }
          };
          if (res === true) {
            if (!this.ndk?.signer) {
              this.debug("No signer available for authentication localhost");
              this.ndk?.once("signer:ready", authenticate);
            } else {
              authenticate().catch((e) => {
                console.error("Error authenticating", e);
              });
            }
          }
          this._status = 5 /* CONNECTED */;
          this.ndkRelay.emit("authed");
        }
      }
    } else {
      this.ndkRelay.emit("auth", challenge);
    }
  }
  /**
   * Handles errors that occur on the WebSocket connection to the relay.
   * @param error - The error or event that occurred.
   */
  onError(error) {
    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);
  }
  /**
   * Gets the current status of the NDK relay connection.
   * @returns {NDKRelayStatus} The current status of the NDK relay connection.
   */
  get status() {
    return this._status;
  }
  /**
   * Checks if the NDK relay connection is currently available.
   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.
   */
  isAvailable() {
    return this._status === 5 /* CONNECTED */;
  }
  /**
   * Checks if the NDK relay connection is flapping, which means the connection is rapidly
   * disconnecting and reconnecting. This is determined by analyzing the durations of the
   * last three connection attempts. If the standard deviation of the durations is less
   * than 1000 milliseconds, the connection is considered to be flapping.
   *
   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.
   */
  isFlapping() {
    const durations = this._connectionStats.durations;
    if (durations.length % 3 !== 0) return false;
    const sum = durations.reduce((a, b) => a + b, 0);
    const avg = sum / durations.length;
    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;
    const stdDev = Math.sqrt(variance);
    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;
    return isFlapping;
  }
  /**
   * Handles a notice received from the NDK relay.
   * If the notice indicates the relay is complaining (e.g. "too many" or "maximum"),
   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.
   * A debug message is logged with the relay URL and the notice text.
   * The "notice" event is emitted on the ndkRelay instance with the notice text.
   *
   * @param notice - The notice text received from the NDK relay.
   */
  async onNotice(notice) {
    this.ndkRelay.emit("notice", notice);
  }
  /**
   * Attempts to reconnect to the NDK relay after a connection is lost.
   * This function is called recursively to handle multiple reconnection attempts.
   * It checks if the relay is flapping and emits a "flapping" event if so.
   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.
   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.
   * If the maximum number of reconnection attempts is reached, a debug message is logged.
   *
   * @param attempt - The current attempt number (default is 0).
   */
  handleReconnection(attempt = 0) {
    if (this.reconnectTimeout) return;
    if (this.isFlapping()) {
      this.ndkRelay.emit("flapping", this._connectionStats);
      this._status = 3 /* FLAPPING */;
      return;
    }
    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);
    this.reconnectTimeout = setTimeout(() => {
      this.reconnectTimeout = void 0;
      this._status = 2 /* RECONNECTING */;
      this.connect().catch((_err) => {
        if (attempt < MAX_RECONNECT_ATTEMPTS) {
          setTimeout(
            () => {
              this.handleReconnection(attempt + 1);
            },
            1e3 * (attempt + 1) ^ 4
          );
        } else {
          this.debug("Reconnect failed");
        }
      });
    }, reconnectDelay);
    this.ndkRelay.emit("delayed-connect", reconnectDelay);
    this.debug("Reconnecting in", reconnectDelay);
    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;
  }
  /**
   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.
   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.
   *
   * @param message - The message to send to the NDK relay.
   * @throws {Error} If attempting to send on a closed relay connection.
   */
  async send(message) {
    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {
      this.ws?.send(message);
      this.netDebug?.(message, this.ndkRelay, "send");
    } else {
      this.debug(
        `Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`,
        this._status
      );
    }
  }
  /**
   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.
   *
   * @param event - The NDK event to authenticate.
   * @returns A promise that resolves with the authentication result.
   */
  async auth(event) {
    const ret = new Promise((resolve, reject) => {
      const val = this.openEventPublishes.get(event.id) ?? [];
      val.push({ resolve, reject });
      this.openEventPublishes.set(event.id, val);
    });
    this.send(`["AUTH",${JSON.stringify(event.rawEvent())}]`);
    return ret;
  }
  /**
   * Publishes an NDK event to the relay and returns a promise that resolves with the result.
   *
   * @param event - The NDK event to publish.
   * @returns A promise that resolves with the result of the event publication.
   * @throws {Error} If attempting to publish on a closed relay connection.
   */
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      const val = this.openEventPublishes.get(event.id) ?? [];
      if (val.length > 0) {
        console.warn(
          `Duplicate event publishing detected, you are publishing event ${event.id} twice`
        );
      }
      val.push({ resolve, reject });
      this.openEventPublishes.set(event.id, val);
    });
    this.send(`["EVENT",${JSON.stringify(event)}]`);
    return ret;
  }
  /**
   * Counts the number of events that match the provided filters.
   *
   * @param filters - The filters to apply to the count request.
   * @param params - An optional object containing a custom id for the count request.
   * @returns A promise that resolves with the number of matching events.
   * @throws {Error} If attempting to send the count request on a closed relay connection.
   */
  async count(filters, params) {
    this.serial++;
    const id = params?.id || `count:${this.serial}`;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send(`["COUNT","${id}",${JSON.stringify(filters).substring(1)}`);
    return ret;
  }
  close(subId, reason) {
    this.send(`["CLOSE","${subId}"]`);
    const sub = this.openSubs.get(subId);
    this.openSubs.delete(subId);
    if (sub) sub.onclose(reason);
  }
  /**
   * Subscribes to the NDK relay with the provided filters and parameters.
   *
   * @param filters - The filters to apply to the subscription.
   * @param params - The subscription parameters, including an optional custom id.
   * @returns A new NDKRelaySubscription instance.
   */
  req(relaySub) {
    `${this.send(`["REQ","${relaySub.subId}",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;
    this.openSubs.set(relaySub.subId, relaySub);
  }
  /**
   * Utility functions to update the connection stats.
   */
  updateConnectionStats = {
    connected: () => {
      this._connectionStats.success++;
      this._connectionStats.connectedAt = Date.now();
    },
    disconnected: () => {
      if (this._connectionStats.connectedAt) {
        this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        );
        if (this._connectionStats.durations.length > 100) {
          this._connectionStats.durations.shift();
        }
      }
      this._connectionStats.connectedAt = void 0;
    },
    attempt: () => {
      this._connectionStats.attempts++;
      this._connectionStats.connectedAt = Date.now();
    }
  };
  /** Returns the connection stats. */
  get connectionStats() {
    return this._connectionStats;
  }
  /** Returns the relay URL */
  get url() {
    return this.ndkRelay.url;
  }
  get connected() {
    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;
  }
};

// src/relay/publisher.ts
var NDKRelayPublisher = class {
  ndkRelay;
  debug;
  constructor(ndkRelay) {
    this.ndkRelay = ndkRelay;
    this.debug = ndkRelay.debug.extend("publisher");
  }
  /**
   * Published an event to the relay; if the relay is not connected, it will
   * wait for the relay to connect before publishing the event.
   *
   * If the relay does not connect within the timeout, the publish operation
   * will fail.
   * @param event  The event to publish
   * @param timeoutMs  The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(event, timeoutMs = 2500) {
    let timeout;
    const publishConnected = () => {
      return new Promise((resolve, reject) => {
        try {
          this.publishEvent(event).then((_result) => {
            this.ndkRelay.emit("published", event);
            event.emit("relay:published", this.ndkRelay);
            resolve(true);
          }).catch(reject);
        } catch (err) {
          reject(err);
        }
      });
    };
    const timeoutPromise = new Promise((_, reject) => {
      timeout = setTimeout(() => {
        timeout = void 0;
        reject(new Error(`Timeout: ${timeoutMs}ms`));
      }, timeoutMs);
    });
    const onConnectHandler = () => {
      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));
    };
    let connectResolve;
    let connectReject;
    const onError = (err) => {
      this.ndkRelay.debug("Publish failed", err, event.id);
      this.ndkRelay.emit("publish:failed", event, err);
      event.emit("relay:publish:failed", this.ndkRelay, err);
      throw err;
    };
    const onFinally = () => {
      if (timeout) clearTimeout(timeout);
      this.ndkRelay.removeListener("connect", onConnectHandler);
    };
    if (this.ndkRelay.status >= 5 /* CONNECTED */) {
      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);
    }
    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {
      console.warn(
        "Relay is disconnected, trying to connect to publish an event",
        this.ndkRelay.url
      );
      this.ndkRelay.connect();
    } else {
      console.warn(
        "Relay not connected, waiting for connection to publish an event",
        this.ndkRelay.url
      );
    }
    return Promise.race([
      new Promise((resolve, reject) => {
        connectResolve = resolve;
        connectReject = reject;
        this.ndkRelay.on("connect", onConnectHandler);
      }),
      timeoutPromise
    ]).catch(onError).finally(onFinally);
  }
  async publishEvent(event) {
    return this.ndkRelay.connectivity.publish(event.rawEvent());
  }
};

// src/subscription/grouping.ts
function filterFingerprint(filters, closeOnEose) {
  const elements = [];
  for (const filter of filters) {
    const keys = Object.entries(filter || {}).map(([key, values]) => {
      if (["since", "until"].includes(key)) {
        return `${key}:${values}`;
      }
      return key;
    }).sort().join("-");
    elements.push(keys);
  }
  let id = closeOnEose ? "+" : "";
  id += elements.join("|");
  return id;
}
function mergeFilters(filters) {
  const result = [];
  const lastResult = {};
  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));
  filters = filters.filter((f) => !f.limit);
  if (filters.length === 0) return result;
  filters.forEach((filter) => {
    Object.entries(filter).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        if (lastResult[key] === void 0) {
          lastResult[key] = [...value];
        } else {
          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));
        }
      } else {
        lastResult[key] = value;
      }
    });
  });
  return [...result, lastResult];
}

// src/relay/subscription.ts
var NDKRelaySubscription = class {
  fingerprint;
  items = /* @__PURE__ */ new Map();
  topSubManager;
  debug;
  /**
   * Tracks the status of this REQ.
   */
  status = 0 /* INITIAL */;
  onClose;
  relay;
  /**
   * Whether this subscription has reached EOSE.
   */
  eosed = false;
  /**
   * Timeout at which this subscription will
   * start executing.
   */
  executionTimer;
  /**
   * Track the time at which this subscription will fire.
   */
  fireTime;
  /**
   * The delay type that the current fireTime was calculated with.
   */
  delayType;
  /**
   * The filters that have been executed.
   */
  executeFilters;
  id = Math.random().toString(36).substring(7);
  /**
   *
   * @param fingerprint The fingerprint of this subscription.
   */
  constructor(relay, fingerprint, topSubManager) {
    this.relay = relay;
    this.topSubManager = topSubManager;
    this.debug = relay.debug.extend(`sub[${this.id}]`);
    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);
  }
  _subId;
  get subId() {
    if (this._subId) return this._subId;
    this._subId = this.fingerprint.slice(0, 15);
    return this._subId;
  }
  subIdParts = /* @__PURE__ */ new Set();
  addSubIdPart(part) {
    this.subIdParts.add(part);
  }
  addItem(subscription, filters) {
    this.debug("Adding item", {
      filters,
      internalId: subscription.internalId,
      status: this.status,
      fingerprint: this.fingerprint,
      id: this.subId,
      items: this.items,
      itemsSize: this.items.size
    });
    if (this.items.has(subscription.internalId)) return;
    subscription.on("close", this.removeItem.bind(this, subscription));
    this.items.set(subscription.internalId, { subscription, filters });
    if (this.status !== 3 /* RUNNING */) {
      if (subscription.subId && (!this._subId || this._subId.length < 48)) {
        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {
          this.addSubIdPart(subscription.subId);
        }
      }
    }
    switch (this.status) {
      case 0 /* INITIAL */:
        this.evaluateExecutionPlan(subscription);
        break;
      case 3 /* RUNNING */:
        break;
      case 1 /* PENDING */:
        this.evaluateExecutionPlan(subscription);
        break;
      case 4 /* CLOSED */:
        this.debug(
          "Subscription is closed, cannot add new items %o (%o)",
          subscription,
          filters
        );
        throw new Error("Cannot add new items to a closed subscription");
    }
  }
  /**
   * A subscription has been closed, remove it from the list of items.
   * @param subscription
   */
  removeItem(subscription) {
    this.items.delete(subscription.internalId);
    if (this.items.size === 0) {
      if (!this.eosed) return;
      this.close();
      this.cleanup();
    }
  }
  close() {
    if (this.status === 4 /* CLOSED */) return;
    const prevStatus = this.status;
    this.status = 4 /* CLOSED */;
    if (prevStatus === 3 /* RUNNING */) {
      try {
        this.relay.close(this.subId);
      } catch (e) {
        this.debug("Error closing subscription", e, this);
      }
    } else {
      this.debug("Subscription wanted to close but it wasn't running, this is probably ok", {
        subId: this.subId,
        prevStatus,
        sub: this
      });
    }
    this.cleanup();
  }
  cleanup() {
    if (this.executionTimer) clearTimeout(this.executionTimer);
    this.relay.off("ready", this.executeOnRelayReady);
    this.relay.off("authed", this.reExecuteAfterAuth);
    if (this.onClose) this.onClose(this);
  }
  evaluateExecutionPlan(subscription) {
    if (!subscription.isGroupable()) {
      this.status = 1 /* PENDING */;
      this.execute();
      return;
    }
    if (subscription.filters.find((filter) => !!filter.limit)) {
      this.executeFilters = this.compileFilters();
      if (this.executeFilters.length >= 10) {
        this.status = 1 /* PENDING */;
        this.execute();
        return;
      }
    }
    const delay = subscription.groupableDelay;
    const delayType = subscription.groupableDelayType;
    if (!delay) throw new Error("Cannot group a subscription without a delay");
    if (this.status === 0 /* INITIAL */) {
      this.schedule(delay, delayType);
    } else {
      const existingDelayType = this.delayType;
      const timeUntilFire = this.fireTime - Date.now();
      if (existingDelayType === "at-least" && delayType === "at-least") {
        if (timeUntilFire < delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-least" && delayType === "at-most") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-most" && delayType === "at-most") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-most" && delayType === "at-least") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else {
        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);
      }
    }
  }
  schedule(delay, delayType) {
    this.status = 1 /* PENDING */;
    const currentTime = Date.now();
    this.fireTime = currentTime + delay;
    this.delayType = delayType;
    const timer = setTimeout(this.execute.bind(this), delay);
    if (delayType === "at-least") {
      this.executionTimer = timer;
    }
  }
  executeOnRelayReady = () => {
    if (this.status !== 2 /* WAITING */) return;
    if (this.items.size === 0) {
      this.debug(
        "No items to execute; this relay was probably too slow to respond and the caller gave up",
        {
          status: this.status,
          fingerprint: this.fingerprint,
          items: this.items,
          itemsSize: this.items.size,
          id: this.id,
          subId: this.subId
        }
      );
      this.cleanup();
      return;
    }
    this.debug("Executing on relay ready", {
      status: this.status,
      fingerprint: this.fingerprint,
      items: this.items,
      itemsSize: this.items.size
    });
    this.status = 1 /* PENDING */;
    this.execute();
  };
  finalizeSubId() {
    if (this.subIdParts.size > 0) {
      this._subId = Array.from(this.subIdParts).join("-");
    } else {
      this._subId = this.fingerprint.slice(0, 15);
    }
    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;
  }
  // we do it this way so that we can remove the listener
  reExecuteAfterAuth = (() => {
    const oldSubId = this.subId;
    this.debug("Re-executing after auth", this.items.size);
    if (this.eosed) {
      this.relay.close(this.subId);
    } else {
      this.debug(
        "We are abandoning an opened subscription, once it EOSE's, the handler will close it",
        {
          oldSubId
        }
      );
    }
    this._subId = void 0;
    this.status = 1 /* PENDING */;
    this.execute();
    this.debug("Re-executed after auth %s \u{1F449} %s", oldSubId, this.subId);
  }).bind(this);
  execute() {
    if (this.status !== 1 /* PENDING */) {
      return;
    }
    if (!this.relay.connected) {
      this.status = 2 /* WAITING */;
      this.debug("Waiting for relay to be ready", {
        status: this.status,
        id: this.subId,
        fingerprint: this.fingerprint,
        items: this.items,
        itemsSize: this.items.size
      });
      this.relay.once("ready", this.executeOnRelayReady);
      return;
    }
    if (this.relay.status < 8 /* AUTHENTICATED */) {
      this.relay.once("authed", this.reExecuteAfterAuth);
    }
    this.status = 3 /* RUNNING */;
    this.finalizeSubId();
    this.executeFilters = this.compileFilters();
    this.relay.req(this);
  }
  onstart() {
  }
  onevent(event) {
    this.topSubManager.dispatchEvent(event, this.relay);
  }
  oneose(subId) {
    this.eosed = true;
    if (subId !== this.subId) {
      this.debug("Received EOSE for an abandoned subscription", subId, this.subId);
      this.relay.close(subId);
      return;
    }
    if (this.items.size === 0) {
      this.close();
    }
    for (const { subscription } of this.items.values()) {
      subscription.eoseReceived(this.relay);
      if (subscription.closeOnEose) {
        this.debug("Removing item because of EOSE", {
          filters: subscription.filters,
          internalId: subscription.internalId,
          status: this.status,
          fingerprint: this.fingerprint,
          items: this.items,
          itemsSize: this.items.size
        });
        this.removeItem(subscription);
      }
    }
  }
  onclose(_reason) {
    this.status = 4 /* CLOSED */;
  }
  onclosed(reason) {
    if (!reason) return;
    for (const { subscription } of this.items.values()) {
      subscription.closedReceived(this.relay, reason);
    }
  }
  /**
   * Grabs the filters from all the subscriptions
   * and merges them into a single filter.
   */
  compileFilters() {
    const mergedFilters = [];
    const filters = Array.from(this.items.values()).map((item) => item.filters);
    if (!filters[0]) {
      this.debug("\u{1F440} No filters to merge", this.items);
      console.error("BUG: No filters to merge!", this.items);
      return [];
    }
    const filterCount = filters[0].length;
    for (let i = 0; i < filterCount; i++) {
      const allFiltersAtIndex = filters.map((filter) => filter[i]);
      mergedFilters.push(...mergeFilters(allFiltersAtIndex));
    }
    return mergedFilters;
  }
};

// src/relay/sub-manager.ts
var NDKRelaySubscriptionManager = class {
  relay;
  subscriptions;
  generalSubManager;
  /**
   * @param relay - The relay instance.
   * @param generalSubManager - The subscription manager instance.
   */
  constructor(relay, generalSubManager) {
    this.relay = relay;
    this.subscriptions = /* @__PURE__ */ new Map();
    this.generalSubManager = generalSubManager;
  }
  /**
   * Adds a subscription to the manager.
   */
  addSubscription(sub, filters) {
    let relaySub;
    if (!sub.isGroupable()) {
      relaySub = this.createSubscription(sub, filters);
    } else {
      const filterFp = filterFingerprint(filters, sub.closeOnEose);
      if (filterFp) {
        const existingSubs = this.subscriptions.get(filterFp);
        relaySub = (existingSubs || []).find(
          (sub2) => sub2.status < 3 /* RUNNING */
        );
      }
      relaySub ??= this.createSubscription(sub, filters, filterFp);
    }
    relaySub.addItem(sub, filters);
  }
  createSubscription(_sub, _filters, fingerprint) {
    const relaySub = new NDKRelaySubscription(
      this.relay,
      fingerprint || null,
      this.generalSubManager
    );
    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);
    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];
    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);
    return relaySub;
  }
  onRelaySubscriptionClose(sub) {
    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];
    if (!currentVal) {
      console.warn(
        "Unexpectedly did not find a subscription with fingerprint",
        sub.fingerprint
      );
    } else if (currentVal.length === 1) {
      this.subscriptions.delete(sub.fingerprint);
    } else {
      currentVal = currentVal.filter((s) => s.id !== sub.id);
      this.subscriptions.set(sub.fingerprint, currentVal);
    }
  }
};

// src/relay/signature-verification-stats.ts
import debug from "debug";

// src/relay/index.ts
var NDKRelay = class _NDKRelay extends EventEmitter2 {
  url;
  scores;
  connectivity;
  subs;
  publisher;
  authPolicy;
  /**
   * The lowest validation ratio this relay can reach.
   */
  lowestValidationRatio;
  /**
   * Current validation ratio this relay is targeting.
   */
  targetValidationRatio;
  validationRatioFn;
  /**
   * This tracks events that have been seen by this relay
   * with a valid signature.
   */
  validatedEventCount = 0;
  /**
   * This tracks events that have been seen by this relay
   * but have not been validated.
   */
  nonValidatedEventCount = 0;
  /**
   * Whether this relay is trusted.
   *
   * Trusted relay's events do not get their signature verified.
   */
  trusted = false;
  complaining = false;
  debug;
  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {
    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0)
      return 1;
    let newRatio = relay.validationRatio;
    if (relay.validationRatio > relay.targetValidationRatio) {
      const factor = validatedCount / 100;
      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);
    }
    if (newRatio < relay.validationRatio) {
      return newRatio;
    }
    return relay.validationRatio;
  };
  constructor(url, authPolicy, ndk) {
    super();
    this.url = normalizeRelayUrl(url);
    this.scores = /* @__PURE__ */ new Map();
    this.debug = debug2(`ndk:relay:${url}`);
    this.connectivity = new NDKRelayConnectivity(this, ndk);
    this.connectivity.netDebug = ndk?.netDebug;
    this.req = this.connectivity.req.bind(this.connectivity);
    this.close = this.connectivity.close.bind(this.connectivity);
    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);
    this.publisher = new NDKRelayPublisher(this);
    this.authPolicy = authPolicy;
    this.targetValidationRatio = ndk?.initialValidationRatio;
    this.lowestValidationRatio = ndk?.lowestValidationRatio;
    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);
    this.updateValidationRatio();
    if (!ndk) {
      console.trace("relay created without ndk");
    }
  }
  updateValidationRatio() {
    if (this.validationRatioFn && this.validatedEventCount > 0) {
      const newRatio = this.validationRatioFn(
        this,
        this.validatedEventCount,
        this.nonValidatedEventCount
      );
      this.targetValidationRatio = newRatio;
    }
    setTimeout(() => {
      this.updateValidationRatio();
    }, 3e4);
  }
  get status() {
    return this.connectivity.status;
  }
  get connectionStats() {
    return this.connectivity.connectionStats;
  }
  /**
   * Connects to the relay.
   */
  async connect(timeoutMs, reconnect = true) {
    return this.connectivity.connect(timeoutMs, reconnect);
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    if (this.status === 1 /* DISCONNECTED */) {
      return;
    }
    this.connectivity.disconnect();
  }
  /**
   * Queues or executes the subscription of a specific set of filters
   * within this relay.
   *
   * @param subscription NDKSubscription this filters belong to.
   * @param filters Filters to execute
   */
  subscribe(subscription, filters) {
    this.subs.addSubscription(subscription, filters);
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(event, timeoutMs = 2500) {
    return this.publisher.publish(event, timeoutMs);
  }
  referenceTags() {
    return [["r", this.url]];
  }
  addValidatedEvent() {
    this.validatedEventCount++;
  }
  addNonValidatedEvent() {
    this.nonValidatedEventCount++;
  }
  /**
   * The current validation ratio this relay has achieved.
   */
  get validationRatio() {
    if (this.nonValidatedEventCount === 0) {
      return 1;
    }
    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);
  }
  shouldValidateEvent() {
    if (this.trusted) {
      return false;
    }
    if (this.targetValidationRatio === void 0) {
      return true;
    }
    if (this.targetValidationRatio >= 1) return true;
    return Math.random() < this.targetValidationRatio;
  }
  get connected() {
    return this.connectivity.connected;
  }
  req;
  close;
};

// test/mocks/relay-mock.ts
var RelayMock = class extends EventEmitter3 {
  url;
  _status = 1 /* DISCONNECTED */;
  messageLog = [];
  activeSubscriptions = /* @__PURE__ */ new Map();
  validatedEvents = 0;
  nonValidatedEvents = 0;
  // Configurable behavior for testing
  options;
  constructor(url = "wss://mock.relay", options = {}) {
    super();
    this.url = url;
    this.options = {
      simulateDisconnect: false,
      disconnectAfter: 5e3,
      connectionDelay: 0,
      autoConnect: true,
      failNextPublish: false,
      ...options
    };
    if (this.options.autoConnect) {
      this.connect();
    }
  }
  // Core methods matching NDKRelay interface
  async connect() {
    this._status = 4 /* CONNECTING */;
    if (this.options.connectionDelay > 0) {
      await new Promise((resolve) => setTimeout(resolve, this.options.connectionDelay));
    }
    this._status = 5 /* CONNECTED */;
    this.emit("connect");
    if (this.options.simulateDisconnect) {
      setTimeout(() => {
        this._status = 1 /* DISCONNECTED */;
        this.emit("disconnect");
      }, this.options.disconnectAfter);
    }
  }
  async disconnect() {
    this._status = 0 /* DISCONNECTING */;
    await Promise.resolve();
    this._status = 1 /* DISCONNECTED */;
    this.emit("disconnect");
  }
  get status() {
    return this._status;
  }
  send(message) {
    if (this.status !== 5 /* CONNECTED */) {
      return;
    }
    this.messageLog.push({ direction: "out", message });
    try {
      const parsed = JSON.parse(message);
      const [type, ...rest] = parsed;
      if (type === "REQ") {
        const [subId, ...filters] = rest;
        const _subscription = Array.from(this.activeSubscriptions.values()).find(
          (sub) => sub.subId === subId
        );
        this.emit("subscription", { id: subId, filters });
      } else if (type === "CLOSE") {
        const [subId] = rest;
        if (this.activeSubscriptions.has(subId)) {
          this.activeSubscriptions.delete(subId);
        }
      }
    } catch (e) {
      console.error(`[RelayMock:${this.url}] Error processing message: ${e}`);
    }
  }
  async publish(event) {
    if (this.options.failNextPublish) {
      this.options.failNextPublish = false;
      return false;
    }
    const eventData = await event.toNostrEvent();
    const message = JSON.stringify(["EVENT", eventData]);
    this.send(message);
    return true;
  }
  subscribe(subscription, filters) {
    const subId = subscription.subId || Math.random().toString(36).substring(2, 15);
    this.activeSubscriptions.set(subId, subscription);
    const message = JSON.stringify(["REQ", subId, ...filters]);
    this.send(message);
  }
  // Method required by NDKSubscription
  shouldValidateEvent() {
    return true;
  }
  // Event tracking methods
  /**
   * Track the number of validated events (used in tests)
   */
  addValidatedEvent() {
    this.validatedEvents += 1;
  }
  /**
   * Track the number of non-validated events (used in tests)
   */
  addNonValidatedEvent() {
    this.nonValidatedEvents += 1;
  }
  // Simulation methods for testing
  /**
   * Simulate receiving a raw message
   */
  simulateReceiveMessage(message) {
    this.messageLog.push({ direction: "in", message });
    this.emit("message", message);
  }
  /**
   * Simulate receiving an event
   */
  async simulateEvent(event, subId) {
    const eventData = await event.toNostrEvent();
    if (subId) {
      const subscription = this.activeSubscriptions.get(subId);
      if (subscription) {
        subscription.eventReceived(event, this);
        const message = JSON.stringify(["EVENT", subId, eventData]);
        this.simulateReceiveMessage(message);
      }
    } else {
      this.activeSubscriptions.forEach((subscription, id) => {
        subscription.eventReceived(event, this);
        const message = JSON.stringify(["EVENT", id, eventData]);
        this.simulateReceiveMessage(message);
      });
    }
  }
  /**
   * Simulate end of stored events
   */
  simulateEOSE(subId) {
    const subscription = this.activeSubscriptions.get(subId);
    if (subscription) {
      subscription.eoseReceived(this);
      const message = JSON.stringify(["EOSE", subId]);
      this.simulateReceiveMessage(message);
    }
  }
  /**
   * Simulate a NOTICE message from the relay
   */
  simulateNotice(message) {
    const noticeMessage = JSON.stringify(["NOTICE", message]);
    this.simulateReceiveMessage(noticeMessage);
  }
  reset() {
    this.messageLog = [];
    this.activeSubscriptions.clear();
    this._status = 1 /* DISCONNECTED */;
    this.validatedEvents = 0;
    this.nonValidatedEvents = 0;
  }
};

// test/mocks/relay-pool-mock.ts
var RelayPoolMock = class {
  mockRelays = /* @__PURE__ */ new Map();
  relays = /* @__PURE__ */ new Set();
  eventListeners = /* @__PURE__ */ new Map();
  onceListeners = /* @__PURE__ */ new Map();
  addMockRelay(url, options = {}) {
    const mockRelay = new RelayMock(url, options);
    this.mockRelays.set(url, mockRelay);
    this.relays.add(mockRelay);
    return mockRelay;
  }
  getMockRelay(url) {
    return this.mockRelays.get(url);
  }
  addRelay(relay) {
    this.relays.add(relay);
    this.mockRelays.set(relay.url, relay);
  }
  removeRelay(relay) {
    this.relays.delete(relay);
    this.mockRelays.delete(relay.url);
  }
  simulateEventOnAll(event) {
    for (const relay of this.mockRelays.values()) {
      relay.simulateEvent(event);
    }
  }
  simulateEventOn(relayUrls, event) {
    for (const url of relayUrls) {
      const relay = this.mockRelays.get(url);
      if (relay) relay.simulateEvent(event);
    }
  }
  simulateEOSEOnAll(subscriptionId) {
    for (const relay of this.mockRelays.values()) {
      relay.simulateEOSE(subscriptionId);
    }
  }
  disconnectAll() {
    for (const relay of this.mockRelays.values()) {
      relay.disconnect();
    }
  }
  resetAll() {
    for (const relay of this.mockRelays.values()) {
      relay.reset();
    }
  }
  // Add this method to support the NDKSubscription implementation
  permanentAndConnectedRelays() {
    return Array.from(this.relays).filter((relay) => relay.status === 2);
  }
  // Add this method to support the eoseReceived method in NDKSubscription
  connectedRelays() {
    return Array.from(this.relays).filter((relay) => relay.status === 2);
  }
  // Add this method to support the NDKSubscription implementation
  getRelay(url, connect = false, createIfNotExists = false, _filters) {
    let relay = this.mockRelays.get(url);
    if (!relay && createIfNotExists) {
      relay = this.addMockRelay(url);
    }
    if (!relay) {
      throw new Error(`Relay ${url} not found and createIfNotExists is false`);
    }
    if (connect && relay.status !== 2) {
      relay.connect();
    }
    return relay;
  }
  // Add event listener support
  on(eventName, callback) {
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(callback);
  }
  // Add 'once' event listener support (required by NDK)
  once(eventName, callback) {
    if (!this.onceListeners.has(eventName)) {
      this.onceListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    const wrappedCallback = (...args) => {
      callback(...args);
      this.onceListeners.get(eventName)?.delete(wrappedCallback);
    };
    this.onceListeners.get(eventName)?.add(wrappedCallback);
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(wrappedCallback);
  }
  // Remove event listener
  off(eventName, callback) {
    if (this.eventListeners.has(eventName)) {
      this.eventListeners.get(eventName)?.delete(callback);
    }
    if (this.onceListeners.has(eventName)) {
      this.onceListeners.get(eventName)?.delete(callback);
    }
  }
  // Trigger an event
  emit(eventName, ...args) {
    if (this.eventListeners.has(eventName)) {
      this.eventListeners.get(eventName)?.forEach((callback) => {
        callback(...args);
      });
    }
  }
};

// src/signers/private-key/index.ts
import { finalizeEvent, generateSecretKey, getPublicKey, nip04, nip44 } from "nostr-tools";
import { bytesToHex as bytesToHex2, hexToBytes as hexToBytes2 } from "@noble/hashes/utils";
import { nip19 as nip197 } from "nostr-tools";

// src/user/index.ts
import { nip19 as nip196 } from "nostr-tools";

// src/events/kinds/nutzap/mint-list.ts
var NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {
  static kind = 10019 /* CashuMintList */;
  static kinds = [10019 /* CashuMintList */];
  _p2pk;
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 10019 /* CashuMintList */;
  }
  static from(event) {
    return new _NDKCashuMintList(event.ndk, event);
  }
  set relays(urls) {
    this.tags = this.tags.filter((t) => t[0] !== "relay");
    for (const url of urls) {
      this.tags.push(["relay", url]);
    }
  }
  get relays() {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "relay") {
        r.push(tag[1]);
      }
    }
    return r;
  }
  set mints(urls) {
    this.tags = this.tags.filter((t) => t[0] !== "mint");
    for (const url of urls) {
      this.tags.push(["mint", url]);
    }
  }
  get mints() {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "mint") {
        r.push(tag[1]);
      }
    }
    return Array.from(new Set(r));
  }
  get p2pk() {
    if (this._p2pk) {
      return this._p2pk;
    }
    this._p2pk = this.tagValue("pubkey") ?? this.pubkey;
    return this._p2pk;
  }
  set p2pk(pubkey) {
    this._p2pk = pubkey;
    this.removeTag("pubkey");
    if (pubkey) {
      this.tags.push(["pubkey", pubkey]);
    }
  }
  get relaySet() {
    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);
  }
};

// src/subscription/index.ts
import { EventEmitter as EventEmitter10 } from "tseep";

// src/events/kinds/article.ts
var NDKArticle = class _NDKArticle extends NDKEvent {
  static kind = 30023 /* Article */;
  static kinds = [30023 /* Article */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 30023 /* Article */;
  }
  /**
   * Creates a NDKArticle from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKArticle from.
   * @returns NDKArticle
   */
  static from(event) {
    return new _NDKArticle(event.ndk, event);
  }
  /**
   * Getter for the article title.
   *
   * @returns {string | undefined} - The article title if available, otherwise undefined.
   */
  get title() {
    return this.tagValue("title");
  }
  /**
   * Setter for the article title.
   *
   * @param {string | undefined} title - The title to set for the article.
   */
  set title(title) {
    this.removeTag("title");
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Getter for the article image.
   *
   * @returns {string | undefined} - The article image if available, otherwise undefined.
   */
  get image() {
    return this.tagValue("image");
  }
  /**
   * Setter for the article image.
   *
   * @param {string | undefined} image - The image to set for the article.
   */
  set image(image) {
    this.removeTag("image");
    if (image) this.tags.push(["image", image]);
  }
  get summary() {
    return this.tagValue("summary");
  }
  set summary(summary) {
    this.removeTag("summary");
    if (summary) this.tags.push(["summary", summary]);
  }
  /**
   * Getter for the article's publication timestamp.
   *
   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.
   */
  get published_at() {
    const tag = this.tagValue("published_at");
    if (tag) {
      let val = Number.parseInt(tag);
      if (val > 1e12) {
        val = Math.floor(val / 1e3);
      }
      return val;
    }
    return void 0;
  }
  /**
   * Setter for the article's publication timestamp.
   *
   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.
   */
  set published_at(timestamp) {
    this.removeTag("published_at");
    if (timestamp !== void 0) {
      this.tags.push(["published_at", timestamp.toString()]);
    }
  }
  /**
   * Generates content tags for the article.
   *
   * This method first checks and sets the publication date if not available,
   * and then generates content tags based on the base NDKEvent class.
   *
   * @returns {ContentTag} - The generated content tags.
   */
  async generateTags() {
    super.generateTags();
    if (!this.published_at) {
      this.published_at = this.created_at;
    }
    return super.generateTags();
  }
  /**
   * Getter for the article's URL.
   *
   * @returns {string | undefined} - The article's URL if available, otherwise undefined.
   */
  get url() {
    return this.tagValue("url");
  }
  /**
   * Setter for the article's URL.
   *
   * @param {string | undefined} url - The URL to set for the article.
   */
  set url(url) {
    if (url) {
      this.tags.push(["url", url]);
    } else {
      this.removeTag("url");
    }
  }
};

// src/relay/pool/index.ts
import { EventEmitter as EventEmitter4 } from "tseep";
var NDKPool = class extends EventEmitter4 {
  // TODO: This should probably be an LRU cache
  _relays = /* @__PURE__ */ new Map();
  status = "idle";
  autoConnectRelays = /* @__PURE__ */ new Set();
  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();
  debug;
  temporaryRelayTimers = /* @__PURE__ */ new Map();
  flappingRelays = /* @__PURE__ */ new Set();
  // A map to store timeouts for each flapping relay.
  backoffTimes = /* @__PURE__ */ new Map();
  ndk;
  get blacklistRelayUrls() {
    const val = new Set(this.ndk.blacklistRelayUrls);
    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));
    return val;
  }
  /**
   * @param relayUrls - The URLs of the relays to connect to.
   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level
   * @param ndk - The NDK instance.
   * @param opts - Options for the pool.
   */
  constructor(relayUrls, blacklistedRelayUrls, ndk, {
    debug: debug9,
    name
  } = {}) {
    super();
    this.debug = debug9 ?? ndk.debug.extend("pool");
    if (name) this._name = name;
    this.ndk = ndk;
    this.relayUrls = relayUrls;
    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);
    this.ndk.pools.push(this);
  }
  get relays() {
    return this._relays;
  }
  set relayUrls(urls) {
    this._relays.clear();
    for (const relayUrl of urls) {
      const relay = new NDKRelay(relayUrl, void 0, this.ndk);
      relay.connectivity.netDebug = this.ndk.netDebug;
      this.addRelay(relay);
    }
  }
  _name = "unnamed";
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this.debug = this.debug.extend(name);
  }
  /**
   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.
   * @param relay - The relay to add to the pool.
   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.
   */
  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {
    const relayAlreadyInPool = this.relays.has(relay.url);
    if (!relayAlreadyInPool) {
      this.addRelay(relay);
      this.debug("Adding temporary relay %s for filters %o", relay.url, filters);
    }
    const existingTimer = this.temporaryRelayTimers.get(relay.url);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    if (!relayAlreadyInPool || existingTimer) {
      const timer = setTimeout(() => {
        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;
        this.removeRelay(relay.url);
      }, removeIfUnusedAfter);
      this.temporaryRelayTimers.set(relay.url, timer);
    }
  }
  /**
   * Adds a relay to the pool.
   *
   * @param relay - The relay to add to the pool.
   * @param connect - Whether or not to connect to the relay.
   */
  addRelay(relay, connect = true) {
    const isAlreadyInPool = this.relays.has(relay.url);
    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);
    const isCustomRelayUrl = relay.url.includes("/npub1");
    let reconnect = true;
    const relayUrl = relay.url;
    if (isAlreadyInPool) return;
    if (isBlacklisted) {
      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);
      return;
    }
    if (isCustomRelayUrl) {
      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);
      return;
    }
    if (this.ndk.cacheAdapter?.getRelayStatus) {
      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);
      if (info?.dontConnectBefore) {
        if (info.dontConnectBefore > Date.now()) {
          const delay = info.dontConnectBefore - Date.now();
          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);
          setTimeout(() => {
            this.addRelay(relay, connect);
          }, delay);
          return;
        }
        reconnect = false;
      }
    }
    const noticeHandler = (notice) => this.emit("notice", relay, notice);
    const connectHandler = () => this.handleRelayConnect(relayUrl);
    const readyHandler = () => this.handleRelayReady(relay);
    const disconnectHandler = () => this.emit("relay:disconnect", relay);
    const flappingHandler = () => this.handleFlapping(relay);
    const authHandler = (challenge) => this.emit("relay:auth", relay, challenge);
    const authedHandler = () => this.emit("relay:authed", relay);
    relay.off("notice", noticeHandler);
    relay.off("connect", connectHandler);
    relay.off("ready", readyHandler);
    relay.off("disconnect", disconnectHandler);
    relay.off("flapping", flappingHandler);
    relay.off("auth", authHandler);
    relay.off("authed", authedHandler);
    relay.on("notice", noticeHandler);
    relay.on("connect", connectHandler);
    relay.on("ready", readyHandler);
    relay.on("disconnect", disconnectHandler);
    relay.on("flapping", flappingHandler);
    relay.on("auth", authHandler);
    relay.on("authed", authedHandler);
    relay.on("delayed-connect", (delay) => {
      if (this.ndk.cacheAdapter?.updateRelayStatus) {
        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {
          dontConnectBefore: Date.now() + delay
        });
      }
    });
    this._relays.set(relayUrl, relay);
    if (connect) this.autoConnectRelays.add(relayUrl);
    if (connect && this.status === "active") {
      this.emit("relay:connecting", relay);
      relay.connect(void 0, reconnect).catch((e) => {
        this.debug(`Failed to connect to relay ${relayUrl}`, e);
      });
    }
  }
  /**
   * Removes a relay from the pool.
   * @param relayUrl - The URL of the relay to remove.
   * @returns {boolean} True if the relay was removed, false if it was not found.
   */
  removeRelay(relayUrl) {
    const relay = this.relays.get(relayUrl);
    if (relay) {
      relay.disconnect();
      this.relays.delete(relayUrl);
      this.autoConnectRelays.delete(relayUrl);
      this.emit("relay:disconnect", relay);
      return true;
    }
    const existingTimer = this.temporaryRelayTimers.get(relayUrl);
    if (existingTimer) {
      clearTimeout(existingTimer);
      this.temporaryRelayTimers.delete(relayUrl);
    }
    return false;
  }
  /**
   * Checks whether a relay is already connected in the pool.
   */
  isRelayConnected(url) {
    const normalizedUrl = normalizeRelayUrl(url);
    const relay = this.relays.get(normalizedUrl);
    if (!relay) return false;
    return relay.status === 5 /* CONNECTED */;
  }
  /**
   * Fetches a relay from the pool, or creates a new one if it does not exist.
   *
   * New relays will be attempted to be connected.
   */
  getRelay(url, connect = true, temporary = false, filters) {
    let relay = this.relays.get(normalizeRelayUrl(url));
    if (!relay) {
      relay = new NDKRelay(url, void 0, this.ndk);
      relay.connectivity.netDebug = this.ndk.netDebug;
      if (temporary) {
        this.useTemporaryRelay(relay, 3e4, filters);
      } else {
        this.addRelay(relay, connect);
      }
    }
    return relay;
  }
  handleRelayConnect(relayUrl) {
    const relay = this.relays.get(relayUrl);
    if (!relay) {
      console.error("NDK BUG: relay not found in pool", { relayUrl });
      return;
    }
    this.emit("relay:connect", relay);
    if (this.stats().connected === this.relays.size) {
      this.emit("connect");
    }
  }
  handleRelayReady(relay) {
    this.emit("relay:ready", relay);
  }
  /**
   * Attempts to establish a connection to each relay in the pool.
   *
   * @async
   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
   * @throws {Error} If any of the connection attempts result in an error or timeout.
   */
  async connect(timeoutMs) {
    this.status = "active";
    this.debug(
      `Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}ms` : ""}...`
    );
    const relaysToConnect = Array.from(this.autoConnectRelays.keys()).map((url) => this.relays.get(url)).filter((relay) => !!relay);
    for (const relay of relaysToConnect) {
      if (relay.status !== 5 /* CONNECTED */ && relay.status !== 4 /* CONNECTING */) {
        this.emit("relay:connecting", relay);
        relay.connect().catch((e) => {
          this.debug(
            `Failed to connect to relay ${relay.url}: ${e ?? "No reason specified"}`
          );
        });
      }
    }
    const allConnected = () => relaysToConnect.every((r) => r.status === 5 /* CONNECTED */);
    const allConnectedPromise = new Promise((resolve) => {
      if (allConnected()) {
        resolve();
        return;
      }
      const listeners = [];
      for (const relay of relaysToConnect) {
        const handler = () => {
          if (allConnected()) {
            for (let i = 0; i < relaysToConnect.length; i++) {
              relaysToConnect[i].off("connect", listeners[i]);
            }
            resolve();
          }
        };
        listeners.push(handler);
        relay.on("connect", handler);
      }
    });
    const timeoutPromise = typeof timeoutMs === "number" ? new Promise((resolve) => setTimeout(resolve, timeoutMs)) : new Promise(() => {
    });
    await Promise.race([allConnectedPromise, timeoutPromise]);
  }
  checkOnFlappingRelays() {
    const flappingRelaysCount = this.flappingRelays.size;
    const totalRelays = this.relays.size;
    if (flappingRelaysCount / totalRelays >= 0.8) {
      for (const relayUrl of this.flappingRelays) {
        this.backoffTimes.set(relayUrl, 0);
      }
    }
  }
  handleFlapping(relay) {
    this.debug(`Relay ${relay.url} is flapping`);
    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;
    currentBackoff = currentBackoff * 2;
    this.backoffTimes.set(relay.url, currentBackoff);
    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);
    setTimeout(() => {
      this.debug(`Attempting to reconnect to ${relay.url}`);
      this.emit("relay:connecting", relay);
      relay.connect();
      this.checkOnFlappingRelays();
    }, currentBackoff);
    relay.disconnect();
    this.emit("flapping", relay);
  }
  size() {
    return this.relays.size;
  }
  /**
   * Returns the status of each relay in the pool.
   * @returns {NDKPoolStats} An object containing the number of relays in each status.
   */
  stats() {
    const stats = {
      total: 0,
      connected: 0,
      disconnected: 0,
      connecting: 0
    };
    for (const relay of this.relays.values()) {
      stats.total++;
      if (relay.status === 5 /* CONNECTED */) {
        stats.connected++;
      } else if (relay.status === 1 /* DISCONNECTED */) {
        stats.disconnected++;
      } else if (relay.status === 4 /* CONNECTING */) {
        stats.connecting++;
      }
    }
    return stats;
  }
  connectedRelays() {
    return Array.from(this.relays.values()).filter(
      (relay) => relay.status >= 5 /* CONNECTED */
    );
  }
  permanentAndConnectedRelays() {
    return Array.from(this.relays.values()).filter(
      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)
    );
  }
  /**
   * Get a list of all relay urls in the pool.
   */
  urls() {
    return Array.from(this.relays.keys());
  }
};

// src/events/kinds/lists/index.ts
var NDKList = class _NDKList extends NDKEvent {
  _encryptedTags;
  static kinds = [
    10063 /* BlossomList */,
    30001 /* CategorizedBookmarkList */,
    10004 /* CommunityList */,
    10050 /* DirectMessageReceiveRelayList */,
    10030 /* EmojiList */,
    10015 /* InterestList */,
    10001 /* PinList */,
    10002 /* RelayList */,
    10007 /* SearchRelayList */,
    10006 /* BlockRelayList */,
    10003 /* BookmarkList */
  ];
  /**
   * Stores the number of bytes the content was before decryption
   * to expire the cache when the content changes.
   */
  encryptedTagsLength;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 30001 /* CategorizedBookmarkList */;
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ndkEvent) {
    return new _NDKList(ndkEvent.ndk, ndkEvent);
  }
  /**
   * Returns the title of the list. Falls back on fetching the name tag value.
   */
  get title() {
    const titleTag = this.tagValue("title") || this.tagValue("name");
    if (titleTag) return titleTag;
    if (this.kind === 3 /* Contacts */) {
      return "Contacts";
    }
    if (this.kind === 1e4 /* MuteList */) {
      return "Mute";
    }
    if (this.kind === 10001 /* PinList */) {
      return "Pinned Notes";
    }
    if (this.kind === 10002 /* RelayList */) {
      return "Relay Metadata";
    }
    if (this.kind === 10003 /* BookmarkList */) {
      return "Bookmarks";
    }
    if (this.kind === 10004 /* CommunityList */) {
      return "Communities";
    }
    if (this.kind === 10005 /* PublicChatList */) {
      return "Public Chats";
    }
    if (this.kind === 10006 /* BlockRelayList */) {
      return "Blocked Relays";
    }
    if (this.kind === 10007 /* SearchRelayList */) {
      return "Search Relays";
    }
    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {
      return "Direct Message Receive Relays";
    }
    if (this.kind === 10015 /* InterestList */) {
      return "Interests";
    }
    if (this.kind === 10030 /* EmojiList */) {
      return "Emojis";
    }
    return this.tagValue("d");
  }
  /**
   * Sets the title of the list.
   */
  set title(title) {
    this.removeTag(["title", "name"]);
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Returns the name of the list.
   * @deprecated Please use "title" instead.
   */
  get name() {
    return this.title;
  }
  /**
   * Sets the name of the list.
   * @deprecated Please use "title" instead. This method will use the `title` tag instead.
   */
  set name(name) {
    this.title = name;
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(name) {
    this.removeTag("description");
    if (name) this.tags.push(["description", name]);
  }
  /**
   * Returns the image of the list.
   */
  get image() {
    return this.tagValue("image");
  }
  /**
   * Sets the image of the list.
   */
  set image(name) {
    this.removeTag("image");
    if (name) this.tags.push(["image", name]);
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(useCache = true) {
    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    const user = await this.ndk.signer.user();
    try {
      if (this.content.length > 0) {
        try {
          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);
          const a = JSON.parse(decryptedContent);
          if (a?.[0]) {
            this.encryptedTagsLength = this.content.length;
            return this._encryptedTags = a;
          }
          this.encryptedTagsLength = this.content.length;
          return this._encryptedTags = [];
        } catch (_e) {
        }
      }
    } catch (_e) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(_tagValue) {
    return true;
  }
  getItems(type) {
    return this.tags.filter((tag) => tag[0] === type);
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((t) => {
      return ![
        "d",
        "L",
        "l",
        "title",
        "name",
        "description",
        "published_at",
        "summary",
        "image",
        "thumb",
        "alt",
        "expiration",
        "subject",
        "client"
      ].includes(t[0]);
    });
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   * @param position Where to add the item in the list (top or bottom)
   */
  async addItem(item, mark = void 0, encrypted = false, position = "bottom") {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    let tags;
    if (item instanceof NDKEvent) {
      tags = [item.tagReference(mark)];
    } else if (item instanceof NDKUser) {
      tags = item.referenceTags();
    } else if (item instanceof NDKRelay) {
      tags = item.referenceTags();
    } else if (Array.isArray(item)) {
      tags = [item];
    } else {
      throw new Error("Invalid object type");
    }
    if (mark) tags[0].push(mark);
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      if (position === "top") currentList.unshift(...tags);
      else currentList.push(...tags);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      if (position === "top") this.tags.unshift(...tags);
      else this.tags.push(...tags);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
  }
  /**
   * Removes an item from the list from both the encrypted and unencrypted lists.
   * @param value value of item to remove from the list
   * @param publish whether to publish the change
   * @returns
   */
  async removeItemByValue(value, publish = true) {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    const index = this.tags.findIndex((tag) => tag[1] === value);
    if (index >= 0) {
      this.tags.splice(index, 1);
    }
    const user = await this.ndk.signer.user();
    const encryptedTags = await this.encryptedTags();
    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);
    if (encryptedIndex >= 0) {
      encryptedTags.splice(encryptedIndex, 1);
      this._encryptedTags = encryptedTags;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(encryptedTags);
      await this.encrypt(user);
    }
    if (publish) {
      return this.publishReplaceable();
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(index, encrypted) {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      currentList.splice(index, 1);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      this.tags.splice(index, 1);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
    return this;
  }
  has(item) {
    return this.items.some((tag) => tag[1] === item);
  }
  /**
   * Creates a filter that will result in fetching
   * the items of this list
   * @example
   * const list = new NDKList(...);
   * const filters = list.filterForItems();
   * const events = await ndk.fetchEvents(filters);
   */
  filterForItems() {
    const ids = /* @__PURE__ */ new Set();
    const nip33Queries = /* @__PURE__ */ new Map();
    const filters = [];
    for (const tag of this.items) {
      if (tag[0] === "e" && tag[1]) {
        ids.add(tag[1]);
      } else if (tag[0] === "a" && tag[1]) {
        const [kind, pubkey, dTag] = tag[1].split(":");
        if (!kind || !pubkey) continue;
        const key = `${kind}:${pubkey}`;
        const item = nip33Queries.get(key) || [];
        item.push(dTag || "");
        nip33Queries.set(key, item);
      }
    }
    if (ids.size > 0) {
      filters.push({ ids: Array.from(ids) });
    }
    if (nip33Queries.size > 0) {
      for (const [key, values] of nip33Queries.entries()) {
        const [kind, pubkey] = key.split(":");
        filters.push({
          kinds: [Number.parseInt(kind)],
          authors: [pubkey],
          "#d": values
        });
      }
    }
    return filters;
  }
};
var lists_default = NDKList;

// src/events/kinds/drafts.ts
var NDKDraft = class _NDKDraft extends NDKEvent {
  _event;
  static kind = 31234 /* Draft */;
  static kinds = [31234 /* Draft */, 1234 /* DraftCheckpoint */];
  /**
   * Can be used to include a different pubkey as part of the draft.
   * This is useful when we want to make the draft a proposal for a different user to publish.
   */
  counterparty;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 31234 /* Draft */;
  }
  static from(event) {
    return new _NDKDraft(event.ndk, event);
  }
  /**
   * Sets an identifier (i.e. d-tag)
   */
  set identifier(id) {
    this.removeTag("d");
    this.tags.push(["d", id]);
  }
  get identifier() {
    return this.dTag;
  }
  /**
   * Event that is to be saved.
   */
  set event(e) {
    if (!(e instanceof NDKEvent)) this._event = new NDKEvent(void 0, e);
    else this._event = e;
    this.prepareEvent();
  }
  /**
   * Marks the event as a checkpoint for another draft event.
   */
  set checkpoint(parent) {
    if (parent) {
      this.tags.push(parent.tagReference());
      this.kind = 1234 /* DraftCheckpoint */;
    } else {
      this.removeTag("a");
      this.kind = 31234 /* Draft */;
    }
  }
  get isCheckpoint() {
    return this.kind === 1234 /* DraftCheckpoint */;
  }
  get isProposal() {
    const pTag = this.tagValue("p");
    return !!pTag && pTag !== this.pubkey;
  }
  /**
   * Gets the event.
   * @param param0
   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).
   */
  async getEvent(signer) {
    if (this._event) return this._event;
    signer ??= this.ndk?.signer;
    if (!signer) throw new Error("No signer available");
    if (this.content && this.content.length > 0) {
      try {
        const ownPubkey = signer.pubkey;
        const pubkeys = [this.tagValue("p"), this.pubkey].filter(Boolean);
        const counterpartyPubkey = pubkeys.find((pubkey) => pubkey !== ownPubkey);
        let user;
        user = new NDKUser({ pubkey: counterpartyPubkey ?? ownPubkey });
        await this.decrypt(user, signer);
        const payload = JSON.parse(this.content);
        this._event = await wrapEvent(new NDKEvent(this.ndk, payload));
        return this._event;
      } catch (e) {
        console.error(e);
        return void 0;
      }
    } else {
      return null;
    }
  }
  prepareEvent() {
    if (!this._event) throw new Error("No event has been provided");
    this.removeTag("k");
    if (this._event.kind) this.tags.push(["k", this._event.kind.toString()]);
    this.content = JSON.stringify(this._event.rawEvent());
  }
  /**
   * Generates draft event.
   *
   * @param signer: Optional signer to encrypt with
   * @param publish: Whether to publish, optionally specifying relaySet to publish to
   */
  async save({
    signer,
    publish,
    relaySet
  }) {
    signer ??= this.ndk?.signer;
    if (!signer) throw new Error("No signer available");
    const user = this.counterparty || await signer.user();
    await this.encrypt(user, signer);
    if (this.counterparty) {
      const pubkey = this.counterparty.pubkey;
      this.removeTag("p");
      this.tags.push(["p", pubkey]);
    }
    if (publish === false) return;
    return this.publishReplaceable(relaySet);
  }
};

// src/utils/imeta.ts
function mapImetaTag(tag) {
  const data = {};
  if (tag.length === 2) {
    const parts = tag[1].split(" ");
    for (let i = 0; i < parts.length; i += 2) {
      const key = parts[i];
      const value = parts[i + 1];
      if (key === "fallback") {
        if (!data.fallback) data.fallback = [];
        data.fallback.push(value);
      } else {
        data[key] = value;
      }
    }
    return data;
  }
  const tags = tag.slice(1);
  for (const val of tags) {
    const parts = val.split(" ");
    const key = parts[0];
    const value = parts.slice(1).join(" ");
    if (key === "fallback") {
      if (!data.fallback) data.fallback = [];
      data.fallback.push(value);
    } else {
      data[key] = value;
    }
  }
  return data;
}
function imetaTagToTag(imeta) {
  const tag = ["imeta"];
  for (const [key, value] of Object.entries(imeta)) {
    if (Array.isArray(value)) {
      for (const v of value) {
        tag.push(`${key} ${v}`);
      }
    } else if (value) {
      tag.push(`${key} ${value}`);
    }
  }
  return tag;
}

// src/events/kinds/story.ts
function strToPosition(positionStr) {
  const [x, y] = positionStr.split(",").map(Number);
  return { x, y };
}
function strToDimension(dimensionStr) {
  const [width, height] = dimensionStr.split("x").map(Number);
  return { width, height };
}
var NDKStorySticker = class _NDKStorySticker {
  static Text = "text" /* Text */;
  static Pubkey = "pubkey" /* Pubkey */;
  static Event = "event" /* Event */;
  static Prompt = "prompt" /* Prompt */;
  static Countdown = "countdown" /* Countdown */;
  type;
  value;
  position;
  dimension;
  properties;
  constructor(arg) {
    if (Array.isArray(arg)) {
      const tag = arg;
      if (tag[0] !== "sticker" || tag.length < 5) {
        throw new Error("Invalid sticker tag");
      }
      this.type = tag[1];
      this.value = tag[2];
      this.position = strToPosition(tag[3]);
      this.dimension = strToDimension(tag[4]);
      const props = {};
      for (let i = 5; i < tag.length; i++) {
        const [key, ...rest] = tag[i].split(" ");
        props[key] = rest.join(" ");
      }
      if (Object.keys(props).length > 0) {
        this.properties = props;
      }
    } else {
      this.type = arg;
      this.value = void 0;
      this.position = { x: 0, y: 0 };
      this.dimension = { width: 0, height: 0 };
    }
  }
  static fromTag(tag) {
    try {
      return new _NDKStorySticker(tag);
    } catch {
      return null;
    }
  }
  get style() {
    return this.properties?.style;
  }
  set style(style) {
    if (style) this.properties = { ...this.properties, style };
    else delete this.properties?.style;
  }
  get rotation() {
    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;
  }
  set rotation(rotation) {
    if (rotation !== void 0) {
      this.properties = { ...this.properties, rot: rotation.toString() };
    } else {
      delete this.properties?.rot;
    }
  }
  /**
   * Checks if the sticker is valid.
   *
   * @returns {boolean} - True if the sticker is valid, false otherwise.
   */
  get isValid() {
    return this.hasValidDimensions() && this.hasValidPosition();
  }
  hasValidDimensions = () => {
    return typeof this.dimension.width === "number" && typeof this.dimension.height === "number" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);
  };
  hasValidPosition = () => {
    return typeof this.position.x === "number" && typeof this.position.y === "number" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);
  };
  toTag() {
    if (!this.isValid) {
      const errors = [
        !this.hasValidDimensions() ? "dimensions is invalid" : void 0,
        !this.hasValidPosition() ? "position is invalid" : void 0
      ].filter(Boolean);
      throw new Error(`Invalid sticker: ${errors.join(", ")}`);
    }
    let value;
    switch (this.type) {
      case "event" /* Event */:
        value = this.value.tagId();
        break;
      case "pubkey" /* Pubkey */:
        value = this.value.pubkey;
        break;
      default:
        value = this.value;
    }
    const tag = [
      "sticker",
      this.type,
      value,
      coordinates(this.position),
      dimension(this.dimension)
    ];
    if (this.properties) {
      for (const [key, propValue] of Object.entries(this.properties)) {
        tag.push(`${key} ${propValue}`);
      }
    }
    return tag;
  }
};
var NDKStory = class _NDKStory extends NDKEvent {
  static kind = 23 /* Story */;
  static kinds = [23 /* Story */];
  _imeta;
  _dimensions;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 23 /* Story */;
    if (rawEvent) {
      for (const tag of rawEvent.tags) {
        switch (tag[0]) {
          case "imeta":
            this._imeta = mapImetaTag(tag);
            break;
          case "dim":
            this.dimensions = strToDimension(tag[1]);
            break;
        }
      }
    }
  }
  /**
   * Creates a NDKStory from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKStory from.
   * @returns NDKStory
   */
  static from(event) {
    return new _NDKStory(event.ndk, event);
  }
  /**
   * Checks if the story is valid (has exactly one imeta tag).
   */
  get isValid() {
    return !!this.imeta;
  }
  /**
   * Gets the first imeta tag (there should only be one).
   */
  get imeta() {
    return this._imeta;
  }
  /**
   * Sets a single imeta tag, replacing any existing ones.
   */
  set imeta(tag) {
    this._imeta = tag;
    this.tags = this.tags.filter((t) => t[0] !== "imeta");
    if (tag) {
      this.tags.push(imetaTagToTag(tag));
    }
  }
  /**
   * Getter for the story dimensions.
   *
   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.
   */
  get dimensions() {
    const dimTag = this.tagValue("dim");
    if (!dimTag) return void 0;
    return strToDimension(dimTag);
  }
  /**
   * Setter for the story dimensions.
   *
   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.
   */
  set dimensions(dimensions) {
    this.removeTag("dim");
    if (dimensions) {
      this.tags.push(["dim", `${dimensions.width}x${dimensions.height}`]);
    }
  }
  /**
   * Getter for the story duration.
   *
   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.
   */
  get duration() {
    const durTag = this.tagValue("dur");
    if (!durTag) return void 0;
    return Number.parseInt(durTag);
  }
  /**
   * Setter for the story duration.
   *
   * @param {number | undefined} duration - The duration in seconds to set for the story.
   */
  set duration(duration) {
    this.removeTag("dur");
    if (duration !== void 0) {
      this.tags.push(["dur", duration.toString()]);
    }
  }
  /**
   * Gets all stickers from the story.
   *
   * @returns {NDKStorySticker[]} - Array of stickers in the story.
   */
  get stickers() {
    const stickers = [];
    for (const tag of this.tags) {
      if (tag[0] !== "sticker" || tag.length < 5) continue;
      const sticker = NDKStorySticker.fromTag(tag);
      if (sticker) stickers.push(sticker);
    }
    return stickers;
  }
  /**
   * Adds a sticker to the story.
   *
   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.
   */
  addSticker(sticker) {
    let stickerToAdd;
    if (sticker instanceof NDKStorySticker) {
      stickerToAdd = sticker;
    } else {
      const tag = [
        "sticker",
        sticker.type,
        typeof sticker.value === "string" ? sticker.value : "",
        coordinates(sticker.position),
        dimension(sticker.dimension)
      ];
      if (sticker.properties) {
        for (const [key, value] of Object.entries(sticker.properties)) {
          tag.push(`${key} ${value}`);
        }
      }
      stickerToAdd = new NDKStorySticker(tag);
      stickerToAdd.value = sticker.value;
    }
    if (stickerToAdd.type === "pubkey" /* Pubkey */) {
      this.tag(stickerToAdd.value);
    } else if (stickerToAdd.type === "event" /* Event */) {
      this.tag(stickerToAdd.value);
    }
    this.tags.push(stickerToAdd.toTag());
  }
  /**
   * Removes a sticker from the story.
   *
   * @param {number} index - The index of the sticker to remove.
   */
  removeSticker(index) {
    const stickers = this.stickers;
    if (index < 0 || index >= stickers.length) return;
    let stickerCount = 0;
    for (let i = 0; i < this.tags.length; i++) {
      if (this.tags[i][0] === "sticker") {
        if (stickerCount === index) {
          this.tags.splice(i, 1);
          break;
        }
        stickerCount++;
      }
    }
  }
};
var coordinates = (position) => `${position.x},${position.y}`;
var dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;

// src/events/kinds/blossom-list.ts
var NDKBlossomList = class _NDKBlossomList extends NDKEvent {
  static kinds = [10063 /* BlossomList */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 10063 /* BlossomList */;
  }
  static from(ndkEvent) {
    return new _NDKBlossomList(ndkEvent.ndk, ndkEvent.rawEvent());
  }
  /**
   * Returns all Blossom servers in the list
   */
  get servers() {
    return this.tags.filter((tag) => tag[0] === "server").map((tag) => tag[1]);
  }
  /**
   * Sets the list of Blossom servers
   */
  set servers(servers) {
    this.tags = this.tags.filter((tag) => tag[0] !== "server");
    for (const server of servers) {
      this.tags.push(["server", server]);
    }
  }
  /**
   * Returns the default Blossom server (first in the list)
   */
  get default() {
    const servers = this.servers;
    return servers.length > 0 ? servers[0] : void 0;
  }
  /**
   * Sets the default Blossom server by moving it to the beginning of the list
   */
  set default(server) {
    if (!server) return;
    const currentServers = this.servers;
    const filteredServers = currentServers.filter((s) => s !== server);
    this.servers = [server, ...filteredServers];
  }
  /**
   * Adds a server to the list if it doesn't already exist
   */
  addServer(server) {
    if (!server) return;
    const currentServers = this.servers;
    if (!currentServers.includes(server)) {
      this.servers = [...currentServers, server];
    }
  }
  /**
   * Removes a server from the list
   */
  removeServer(server) {
    if (!server) return;
    const currentServers = this.servers;
    this.servers = currentServers.filter((s) => s !== server);
  }
};

// src/events/kinds/follow-pack.ts
var NDKFollowPack = class _NDKFollowPack extends NDKEvent {
  static kind = 39089 /* FollowPack */;
  static kinds = [39089 /* FollowPack */, 39092 /* MediaFollowPack */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 39089 /* FollowPack */;
  }
  /**
   * Converts a generic NDKEvent to an NDKFollowPack.
   */
  static from(ndkEvent) {
    return new _NDKFollowPack(ndkEvent.ndk, ndkEvent);
  }
  /**
   * Gets the title from the tags.
   */
  get title() {
    return this.tagValue("title");
  }
  /**
   * Sets the title tag.
   */
  set title(value) {
    this.removeTag("title");
    if (value) this.tags.push(["title", value]);
  }
  /**
   * Gets the image URL from the tags.
   */
  /**
   * Gets the image URL from the tags.
   * Looks for an imeta tag first (returns its url), then falls back to the image tag.
   */
  get image() {
    const imetaTag = this.tags.find((tag) => tag[0] === "imeta");
    if (imetaTag) {
      const imeta = mapImetaTag(imetaTag);
      if (imeta.url) return imeta.url;
    }
    return this.tagValue("image");
  }
  /**
   * Sets the image URL tag.
   */
  /**
   * Sets the image tag.
   * Accepts a string (URL) or an NDKImetaTag.
   * If given an NDKImetaTag, sets both the imeta tag and the image tag (using the url).
   * If undefined, removes both tags.
   */
  set image(value) {
    this.tags = this.tags.filter((tag) => tag[0] !== "imeta" && tag[0] !== "image");
    if (typeof value === "string") {
      if (value !== void 0) {
        this.tags.push(["image", value]);
      }
    } else if (value && typeof value === "object") {
      this.tags.push(imetaTagToTag(value));
      if (value.url) {
        this.tags.push(["image", value.url]);
      }
    }
  }
  /**
   * Gets all pubkeys from p tags.
   */
  get pubkeys() {
    return Array.from(new Set(this.tags.filter((tag) => tag[0] === "p").map((tag) => tag[1])));
  }
  /**
   * Sets the pubkeys (replaces all p tags).
   */
  set pubkeys(pubkeys) {
    this.tags = this.tags.filter((tag) => tag[0] !== "p");
    for (const pubkey of pubkeys) {
      this.tags.push(["p", pubkey]);
    }
  }
  /**
   * Gets the description from the tags.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description tag.
   */
  set description(value) {
    this.removeTag("description");
    if (value) this.tags.push(["description", value]);
  }
};

// src/events/kinds/highlight.ts
import { nip19 as nip193 } from "nostr-tools";
var NDKHighlight = class _NDKHighlight extends NDKEvent {
  _article;
  static kind = 9802 /* Highlight */;
  static kinds = [9802 /* Highlight */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 9802 /* Highlight */;
  }
  static from(event) {
    return new _NDKHighlight(event.ndk, event);
  }
  get url() {
    return this.tagValue("r");
  }
  /**
   * Context tag.
   */
  set context(context) {
    if (context === void 0) {
      this.tags = this.tags.filter(([tag, _value]) => tag !== "context");
    } else {
      this.tags = this.tags.filter(([tag, _value]) => tag !== "context");
      this.tags.push(["context", context]);
    }
  }
  get context() {
    return this.tags.find(([tag, _value]) => tag === "context")?.[1] ?? void 0;
  }
  /**
   * Will return the article URL or NDKEvent if they have already been
   * set (it won't attempt to load remote events)
   */
  get article() {
    return this._article;
  }
  /**
   * Article the highlight is coming from.
   *
   * @param article Article URL or NDKEvent.
   */
  set article(article) {
    this._article = article;
    if (typeof article === "string") {
      this.tags.push(["r", article]);
    } else {
      this.tag(article);
    }
  }
  getArticleTag() {
    return this.getMatchingTags("a")[0] || this.getMatchingTags("e")[0] || this.getMatchingTags("r")[0];
  }
  async getArticle() {
    if (this._article !== void 0) return this._article;
    let taggedBech32;
    const articleTag = this.getArticleTag();
    if (!articleTag) return void 0;
    switch (articleTag[0]) {
      case "a": {
        const [kind, pubkey, identifier] = articleTag[1].split(":");
        taggedBech32 = nip193.naddrEncode({
          kind: Number.parseInt(kind),
          pubkey,
          identifier
        });
        break;
      }
      case "e":
        taggedBech32 = nip193.noteEncode(articleTag[1]);
        break;
      case "r":
        this._article = articleTag[1];
        break;
    }
    if (taggedBech32) {
      let a = await this.ndk?.fetchEvent(taggedBech32);
      if (a) {
        if (a.kind === 30023 /* Article */) {
          a = NDKArticle.from(a);
        }
        this._article = a;
      }
    }
    return this._article;
  }
};

// src/events/kinds/cashu/tx.ts
var MARKERS = {
  REDEEMED: "redeemed",
  CREATED: "created",
  DESTROYED: "destroyed",
  RESERVED: "reserved"
};
var NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {
  static MARKERS = MARKERS;
  static kind = 7376 /* CashuWalletTx */;
  static kinds = [7376 /* CashuWalletTx */];
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 7376 /* CashuWalletTx */;
  }
  static async from(event) {
    const walletChange = new _NDKCashuWalletTx(event.ndk, event);
    const prevContent = walletChange.content;
    try {
      await walletChange.decrypt();
    } catch (_e) {
      walletChange.content ??= prevContent;
    }
    try {
      const contentTags = JSON.parse(walletChange.content);
      walletChange.tags = [...contentTags, ...walletChange.tags];
    } catch (_e) {
      return;
    }
    return walletChange;
  }
  set direction(direction) {
    this.removeTag("direction");
    if (direction) this.tags.push(["direction", direction]);
  }
  get direction() {
    return this.tagValue("direction");
  }
  set amount(amount) {
    this.removeTag("amount");
    this.tags.push(["amount", amount.toString()]);
  }
  get amount() {
    const val = this.tagValue("amount");
    if (val === void 0) return void 0;
    return Number(val);
  }
  set fee(fee) {
    this.removeTag("fee");
    this.tags.push(["fee", fee.toString()]);
  }
  get fee() {
    const val = this.tagValue("fee");
    if (val === void 0) return void 0;
    return Number(val);
  }
  set unit(unit) {
    this.removeTag("unit");
    if (unit) this.tags.push(["unit", unit.toString()]);
  }
  get unit() {
    return this.tagValue("unit");
  }
  set description(description) {
    this.removeTag("description");
    if (description) this.tags.push(["description", description.toString()]);
  }
  get description() {
    return this.tagValue("description");
  }
  set mint(mint) {
    this.removeTag("mint");
    if (mint) this.tags.push(["mint", mint.toString()]);
  }
  get mint() {
    return this.tagValue("mint");
  }
  /**
   * Tags tokens that were created in this history event
   */
  set destroyedTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.DESTROYED));
    }
  }
  set destroyedTokenIds(ids) {
    for (const id of ids) {
      this.tags.push(["e", id, "", MARKERS.DESTROYED]);
    }
  }
  /**
   * Tags tokens that were created in this history event
   */
  set createdTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.CREATED));
    }
  }
  set reservedTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.RESERVED));
    }
  }
  addRedeemedNutzap(event) {
    this.tag(event, MARKERS.REDEEMED);
  }
  async toNostrEvent(pubkey) {
    const encryptedTags = [];
    const unencryptedTags = [];
    for (const tag of this.tags) {
      if (!this.shouldEncryptTag(tag)) {
        unencryptedTags.push(tag);
      } else {
        encryptedTags.push(tag);
      }
    }
    this.tags = unencryptedTags.filter((t) => t[0] !== "client");
    this.content = JSON.stringify(encryptedTags);
    const user = await this.ndk?.signer?.user();
    if (user) {
      const ownPubkey = user.pubkey;
      this.tags = this.tags.filter((t) => t[0] !== "p" || t[1] !== ownPubkey);
    }
    await this.encrypt(user, void 0, "nip44");
    return super.toNostrEvent(pubkey);
  }
  /**
   * Whether this entry includes a redemption of a Nutzap
   */
  get hasNutzapRedemption() {
    return this.getMatchingTags("e", MARKERS.REDEEMED).length > 0;
  }
  shouldEncryptTag(tag) {
    const unencryptedTagNames = ["client"];
    if (unencryptedTagNames.includes(tag[0])) {
      return false;
    }
    if (tag[0] === "e" && tag[3] === MARKERS.REDEEMED) {
      return false;
    }
    if (tag[0] === "p") return false;
    return true;
  }
};

// src/events/kinds/image.ts
var NDKImage = class _NDKImage extends NDKEvent {
  static kind = 20 /* Image */;
  static kinds = [20 /* Image */];
  _imetas;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 20 /* Image */;
  }
  /**
   * Creates a NDKImage from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKImage from.
   * @returns NDKImage
   */
  static from(event) {
    return new _NDKImage(event.ndk, event.rawEvent());
  }
  get isValid() {
    return this.imetas.length > 0;
  }
  get imetas() {
    if (this._imetas) return this._imetas;
    this._imetas = this.tags.filter((tag) => tag[0] === "imeta").map(mapImetaTag).filter((imeta) => !!imeta.url);
    return this._imetas;
  }
  set imetas(tags) {
    this._imetas = tags;
    this.tags = this.tags.filter((tag) => tag[0] !== "imeta");
    this.tags.push(...tags.map(imetaTagToTag));
  }
};

// src/events/kinds/NDKRelayList.ts
var READ_MARKER = "read";
var WRITE_MARKER = "write";
var NDKRelayList = class _NDKRelayList extends NDKEvent {
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 10002 /* RelayList */;
  }
  static from(ndkEvent) {
    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());
  }
  get readRelayUrls() {
    return this.tags.filter((tag) => tag[0] === "r" || tag[0] === "relay").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);
  }
  set readRelayUrls(relays) {
    for (const relay of relays) {
      this.tags.push(["r", relay, READ_MARKER]);
    }
  }
  get writeRelayUrls() {
    return this.tags.filter((tag) => tag[0] === "r" || tag[0] === "relay").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);
  }
  set writeRelayUrls(relays) {
    for (const relay of relays) {
      this.tags.push(["r", relay, WRITE_MARKER]);
    }
  }
  get bothRelayUrls() {
    return this.tags.filter((tag) => tag[0] === "r" || tag[0] === "relay").filter((tag) => !tag[2]).map((tag) => tag[1]);
  }
  set bothRelayUrls(relays) {
    for (const relay of relays) {
      this.tags.push(["r", relay]);
    }
  }
  get relays() {
    return this.tags.filter((tag) => tag[0] === "r" || tag[0] === "relay").map((tag) => tag[1]);
  }
  /**
   * Provides a relaySet for the relays in this list.
   */
  get relaySet() {
    if (!this.ndk) throw new Error("NDKRelayList has no NDK instance");
    return new NDKRelaySet(
      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),
      this.ndk
    );
  }
};
function relayListFromKind3(ndk, contactList) {
  try {
    const content = JSON.parse(contactList.content);
    const relayList = new NDKRelayList(ndk);
    const readRelays = /* @__PURE__ */ new Set();
    const writeRelays = /* @__PURE__ */ new Set();
    for (let [key, config] of Object.entries(content)) {
      try {
        key = normalizeRelayUrl(key);
      } catch {
        continue;
      }
      if (!config) {
        readRelays.add(key);
        writeRelays.add(key);
      } else {
        const relayConfig = config;
        if (relayConfig.write) writeRelays.add(key);
        if (relayConfig.read) readRelays.add(key);
      }
    }
    relayList.readRelayUrls = Array.from(readRelays);
    relayList.writeRelayUrls = Array.from(writeRelays);
    return relayList;
  } catch {
  }
  return void 0;
}

// src/events/kinds/nutzap/index.ts
import debug3 from "debug";
var NDKNutzap = class _NDKNutzap extends NDKEvent {
  debug;
  _proofs = [];
  static kind = 9321 /* Nutzap */;
  static kinds = [_NDKNutzap.kind];
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 9321 /* Nutzap */;
    this.debug = ndk?.debug.extend("nutzap") ?? debug3("ndk:nutzap");
    if (!this.alt) this.alt = "This is a nutzap";
    try {
      const proofTags = this.getMatchingTags("proof");
      if (proofTags.length) {
        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));
      } else {
        this._proofs = JSON.parse(this.content);
      }
    } catch {
      return;
    }
  }
  static from(event) {
    const e = new _NDKNutzap(event.ndk, event);
    if (!e._proofs || !e._proofs.length) return;
    return e;
  }
  set comment(comment) {
    this.content = comment ?? "";
  }
  get comment() {
    const c = this.tagValue("comment");
    if (c) return c;
    return this.content;
  }
  set proofs(proofs) {
    this._proofs = proofs;
    this.tags = this.tags.filter((tag) => tag[0] !== "proof");
    for (const proof of proofs) {
      this.tags.push(["proof", JSON.stringify(proof)]);
    }
  }
  get proofs() {
    return this._proofs;
  }
  get rawP2pk() {
    const firstProof = this.proofs[0];
    try {
      const secret = JSON.parse(firstProof.secret);
      let payload;
      if (typeof secret === "string") {
        payload = JSON.parse(secret);
        this.debug("stringified payload", firstProof.secret);
      } else if (typeof secret === "object") {
        payload = secret;
      }
      if (Array.isArray(payload) && payload[0] === "P2PK" && payload.length > 1 && typeof payload[1] === "object" && payload[1] !== null) {
        return payload[1].data;
      }
      if (typeof payload === "object" && payload !== null && typeof payload[1]?.data === "string") {
        return payload[1].data;
      }
    } catch (e) {
      this.debug("error parsing p2pk pubkey", e, this.proofs[0]);
    }
    return void 0;
  }
  /**
   * Gets the p2pk pubkey that is embedded in the first proof.
   *
   * Note that this returns a nostr pubkey, not a cashu pubkey (no "02" prefix)
   */
  get p2pk() {
    const rawP2pk = this.rawP2pk;
    if (!rawP2pk) return;
    return rawP2pk.startsWith("02") ? rawP2pk.slice(2) : rawP2pk;
  }
  /**
   * Get the mint where this nutzap proofs exist
   */
  get mint() {
    return this.tagValue("u");
  }
  set mint(value) {
    this.replaceTag(["u", value]);
  }
  get unit() {
    let _unit = this.tagValue("unit") ?? "sat";
    if (_unit?.startsWith("msat")) _unit = "sat";
    return _unit;
  }
  set unit(value) {
    this.removeTag("unit");
    if (value?.startsWith("msat"))
      throw new Error("msat is not allowed, use sat denomination instead");
    if (value) this.tag(["unit", value]);
  }
  get amount() {
    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);
    return amount;
  }
  sender = this.author;
  /**
   * Set the target of the nutzap
   * @param target The target of the nutzap (a user or an event)
   */
  set target(target) {
    this.tags = this.tags.filter((t) => t[0] !== "p");
    if (target instanceof NDKEvent) {
      this.tags.push(target.tagReference());
    }
  }
  set recipientPubkey(pubkey) {
    this.removeTag("p");
    this.tag(["p", pubkey]);
  }
  get recipientPubkey() {
    return this.tagValue("p");
  }
  get recipient() {
    const pubkey = this.recipientPubkey;
    if (this.ndk) return this.ndk.getUser({ pubkey });
    return new NDKUser({ pubkey });
  }
  async toNostrEvent() {
    if (this.unit === "msat") {
      this.unit = "sat";
    }
    this.removeTag("amount");
    this.tags.push(["amount", this.amount.toString()]);
    const event = await super.toNostrEvent();
    event.content = this.comment;
    return event;
  }
  /**
   * Validates that the nutzap conforms to NIP-61
   */
  get isValid() {
    let eTagCount = 0;
    let pTagCount = 0;
    let mintTagCount = 0;
    for (const tag of this.tags) {
      if (tag[0] === "e") eTagCount++;
      if (tag[0] === "p") pTagCount++;
      if (tag[0] === "u") mintTagCount++;
    }
    return (
      // exactly one recipient and mint
      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag
      eTagCount <= 1 && // must have at least one proof
      this.proofs.length > 0
    );
  }
};

// src/events/kinds/subscriptions/amount.ts
var possibleIntervalFrequencies = [
  "daily",
  "weekly",
  "monthly",
  "quarterly",
  "yearly"
];
function newAmount(amount, currency, term) {
  return ["amount", amount.toString(), currency, term];
}
function parseTagToSubscriptionAmount(tag) {
  const amount = Number.parseInt(tag[1]);
  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0)
    return void 0;
  const currency = tag[2];
  if (currency === void 0 || currency === "") return void 0;
  const term = tag[3];
  if (term === void 0) return void 0;
  if (!possibleIntervalFrequencies.includes(term)) return void 0;
  return {
    amount,
    currency,
    term
  };
}

// src/events/kinds/subscriptions/receipt.ts
import debug4 from "debug";

// src/events/kinds/subscriptions/subscription-start.ts
import debug5 from "debug";

// src/events/kinds/subscriptions/tier.ts
var NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {
  static kind = 37001 /* SubscriptionTier */;
  static kinds = [37001 /* SubscriptionTier */];
  constructor(ndk, rawEvent) {
    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;
    super(ndk, rawEvent);
    this.kind = k;
  }
  /**
   * Creates a new NDKSubscriptionTier from an event
   * @param event
   * @returns NDKSubscriptionTier
   */
  static from(event) {
    return new _NDKSubscriptionTier(event.ndk, event);
  }
  /**
   * Returns perks for this tier
   */
  get perks() {
    return this.getMatchingTags("perk").map((tag) => tag[1]).filter((perk) => perk !== void 0);
  }
  /**
   * Adds a perk to this tier
   */
  addPerk(perk) {
    this.tags.push(["perk", perk]);
  }
  /**
   * Returns the amount for this tier
   */
  get amounts() {
    return this.getMatchingTags("amount").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);
  }
  /**
   * Adds an amount to this tier
   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)
   * @param currency Currency code. Use msat for millisatoshis
   * @param term One of daily, weekly, monthly, quarterly, yearly
   */
  addAmount(amount, currency, term) {
    this.tags.push(newAmount(amount, currency, term));
  }
  /**
   * Sets a relay where content related to this tier can be found
   * @param relayUrl URL of the relay
   */
  set relayUrl(relayUrl) {
    this.tags.push(["r", relayUrl]);
  }
  /**
   * Returns the relay URLs for this tier
   */
  get relayUrls() {
    return this.getMatchingTags("r").map((tag) => tag[1]).filter((relay) => relay !== void 0);
  }
  /**
   * Gets the verifier pubkey for this tier. This is the pubkey that will generate
   * subscription payment receipts
   */
  get verifierPubkey() {
    return this.tagValue("p");
  }
  /**
   * Sets the verifier pubkey for this tier.
   */
  set verifierPubkey(pubkey) {
    this.removeTag("p");
    if (pubkey) this.tags.push(["p", pubkey]);
  }
  /**
   * Checks if this tier is valid
   */
  get isValid() {
    return this.title !== void 0 && // Must have a title
    this.amounts.length > 0;
  }
};

// src/events/kinds/video.ts
var NDKVideo = class _NDKVideo extends NDKEvent {
  static kind = 21 /* Video */;
  static kinds = [
    34235 /* HorizontalVideo */,
    34236 /* VerticalVideo */,
    22 /* ShortVideo */,
    21 /* Video */
  ];
  _imetas;
  /**
   * Creates a NDKArticle from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKArticle from.
   * @returns NDKArticle
   */
  static from(event) {
    return new _NDKVideo(event.ndk, event.rawEvent());
  }
  /**
   * Getter for the article title.
   *
   * @returns {string | undefined} - The article title if available, otherwise undefined.
   */
  get title() {
    return this.tagValue("title");
  }
  /**
   * Setter for the article title.
   *
   * @param {string | undefined} title - The title to set for the article.
   */
  set title(title) {
    this.removeTag("title");
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Getter for the article thumbnail.
   *
   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.
   */
  get thumbnail() {
    let thumbnail;
    if (this.imetas && this.imetas.length > 0) {
      thumbnail = this.imetas[0].image?.[0];
    }
    return thumbnail ?? this.tagValue("thumb");
  }
  get imetas() {
    if (this._imetas) return this._imetas;
    this._imetas = this.tags.filter((tag) => tag[0] === "imeta").map(mapImetaTag);
    return this._imetas;
  }
  set imetas(tags) {
    this._imetas = tags;
    this.tags = this.tags.filter((tag) => tag[0] !== "imeta");
    this.tags.push(...tags.map(imetaTagToTag));
  }
  get url() {
    if (this.imetas && this.imetas.length > 0) {
      return this.imetas[0].url;
    }
    return this.tagValue("url");
  }
  /**
   * Getter for the article's publication timestamp.
   *
   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.
   */
  get published_at() {
    const tag = this.tagValue("published_at");
    if (tag) {
      return Number.parseInt(tag);
    }
    return void 0;
  }
  /**
   * Generates content tags for the article.
   *
   * This method first checks and sets the publication date if not available,
   * and then generates content tags based on the base NDKEvent class.
   *
   * @returns {ContentTag} - The generated content tags.
   */
  async generateTags() {
    super.generateTags();
    if (!this.kind) {
      if (this.imetas?.[0]?.dim) {
        const [width, height] = this.imetas[0].dim.split("x");
        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);
        const isShort = this.duration && this.duration < 120;
        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;
        else this.kind = 21 /* Video */;
      }
    }
    return super.generateTags();
  }
  get duration() {
    const tag = this.tagValue("duration");
    if (tag) {
      return Number.parseInt(tag);
    }
    return void 0;
  }
  /**
   * Setter for the video's duration
   *
   * @param {number | undefined} duration - The duration to set for the video (in seconds)
   */
  set duration(dur) {
    this.removeTag("duration");
    if (dur !== void 0) {
      this.tags.push(["duration", Math.floor(dur).toString()]);
    }
  }
};

// src/events/kinds/wiki.ts
var NDKWiki = class _NDKWiki extends NDKArticle {
  static kind = 30818 /* Wiki */;
  static kinds = [30818 /* Wiki */];
  static from(event) {
    return new _NDKWiki(event.ndk, event.rawEvent());
  }
  get isDefered() {
    return this.hasTag("a", "defer");
  }
  get deferedId() {
    return this.tagValue("a", "defer");
  }
  /**
   * Defers the author's wiki event to another wiki event.
   *
   * Wiki-events can tag other wiki-events with a `defer` marker to indicate that it considers someone else's entry as a "better" version of itself. If using a `defer` marker both `a` and `e` tags SHOULD be used.
   *
   * @example
   * myWiki.defer = betterWikiEntryOnTheSameTopic;
   * myWiki.publishReplaceable()
   */
  set defer(deferedTo) {
    this.removeTag("a", "defer");
    this.tag(deferedTo, "defer");
  }
};
var NDKWikiMergeRequest = class _NDKWikiMergeRequest extends NDKEvent {
  static kind = 818 /* WikiMergeRequest */;
  static kinds = [818 /* WikiMergeRequest */];
  static from(event) {
    return new _NDKWikiMergeRequest(event.ndk, event.rawEvent());
  }
  /**
   * The target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.
   */
  get targetId() {
    return this.tagValue("a");
  }
  /**
   * Sets the target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.
   */
  set target(targetEvent) {
    this.tags = this.tags.filter((tag) => {
      if (tag[0] === "a") return true;
      if (tag[0] === "e" && tag[3] !== "source") return true;
    });
    this.tag(targetEvent);
  }
  /**
   * The source ID of the wiki event to merge from.
   */
  get sourceId() {
    return this.tagValue("e", "source");
  }
  /**
   * Sets the event we are asking to get merged into the target.
   */
  set source(sourceEvent) {
    this.removeTag("e", "source");
    this.tag(sourceEvent, "source", false, "e");
  }
};

// src/events/kinds/project.ts
var NDKProject = class _NDKProject extends NDKEvent {
  static kind = 31933;
  static kinds = [_NDKProject.kind];
  _signer;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind = 31933;
  }
  static from(event) {
    return new _NDKProject(event.ndk, event.rawEvent());
  }
  set repo(value) {
    this.removeTag("repo");
    if (value) this.tags.push(["repo", value]);
  }
  set hashtags(values) {
    this.removeTag("hashtags");
    if (values.filter((t) => t.length > 0).length) this.tags.push(["hashtags", ...values]);
  }
  get hashtags() {
    const tag = this.tags.find((tag2) => tag2[0] === "hashtags");
    return tag ? tag.slice(1) : [];
  }
  get repo() {
    return this.tagValue("repo");
  }
  get title() {
    return this.tagValue("title");
  }
  set title(value) {
    this.removeTag("title");
    if (value) this.tags.push(["title", value]);
  }
  get picture() {
    return this.tagValue("picture");
  }
  set picture(value) {
    this.removeTag("picture");
    if (value) this.tags.push(["picture", value]);
  }
  set description(value) {
    this.content = value;
  }
  get description() {
    return this.content;
  }
  /**
   * The project slug, derived from the 'd' tag.
   */
  get slug() {
    return this.dTag ?? "empty-dtag";
  }
  async getSigner() {
    if (this._signer) return this._signer;
    const encryptedKey = this.tagValue("key");
    if (!encryptedKey) {
      this._signer = NDKPrivateKeySigner.generate();
      await this.encryptAndSaveNsec();
    } else {
      const decryptedKey = await this.ndk?.signer?.decrypt(
        this.ndk.activeUser,
        encryptedKey
      );
      if (!decryptedKey) {
        throw new Error("Failed to decrypt project key or missing signer context.");
      }
      this._signer = new NDKPrivateKeySigner(decryptedKey);
    }
    return this._signer;
  }
  async getNsec() {
    const signer = await this.getSigner();
    return signer.privateKey;
  }
  async setNsec(value) {
    this._signer = new NDKPrivateKeySigner(value);
    await this.encryptAndSaveNsec();
  }
  async encryptAndSaveNsec() {
    if (!this._signer) throw new Error("Signer is not set.");
    const key = this._signer.privateKey;
    const encryptedKey = await this.ndk?.signer?.encrypt(this.ndk.activeUser, key);
    if (encryptedKey) {
      this.removeTag("key");
      this.tags.push(["key", encryptedKey]);
    }
  }
};

// src/events/kinds/task.ts
var NDKTask = class _NDKTask extends NDKEvent {
  static kind = 1934;
  static kinds = [1934];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind = 1934;
  }
  static from(event) {
    return new _NDKTask(event.ndk, event.rawEvent());
  }
  set title(value) {
    this.removeTag("title");
    if (value) this.tags.push(["title", value]);
  }
  get title() {
    return this.tagValue("title");
  }
  set project(project) {
    this.removeTag("a");
    this.tags.push(project.tagReference());
  }
  get projectSlug() {
    const tag = this.getMatchingTags("a")[0];
    return tag ? tag[1].split(/:/)?.[2] : void 0;
  }
};

// src/events/kinds/project-template.ts
var NDKProjectTemplate = class _NDKProjectTemplate extends NDKEvent {
  static kind = 30717;
  static kinds = [30717];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind = 30717;
  }
  static from(event) {
    return new _NDKProjectTemplate(event.ndk, event.rawEvent());
  }
  /**
   * Template identifier from 'd' tag
   */
  get templateId() {
    return this.dTag ?? "";
  }
  set templateId(value) {
    this.dTag = value;
  }
  /**
   * Template name from 'title' tag
   */
  get name() {
    return this.tagValue("title") ?? "";
  }
  set name(value) {
    this.removeTag("title");
    if (value) this.tags.push(["title", value]);
  }
  /**
   * Template description from 'description' tag
   */
  get description() {
    return this.tagValue("description") ?? "";
  }
  set description(value) {
    this.removeTag("description");
    if (value) this.tags.push(["description", value]);
  }
  /**
   * Git repository URL from 'uri' tag
   */
  get repoUrl() {
    return this.tagValue("uri") ?? "";
  }
  set repoUrl(value) {
    this.removeTag("uri");
    if (value) this.tags.push(["uri", value]);
  }
  /**
   * Template preview image URL from 'image' tag
   */
  get image() {
    return this.tagValue("image");
  }
  set image(value) {
    this.removeTag("image");
    if (value) this.tags.push(["image", value]);
  }
  /**
   * Command to run from 'command' tag
   */
  get command() {
    return this.tagValue("command");
  }
  set command(value) {
    this.removeTag("command");
    if (value) this.tags.push(["command", value]);
  }
  /**
   * Agent configuration from 'agent' tag
   */
  get agentConfig() {
    const agentTag = this.tagValue("agent");
    if (!agentTag) return void 0;
    try {
      return JSON.parse(agentTag);
    } catch {
      return void 0;
    }
  }
  set agentConfig(value) {
    this.removeTag("agent");
    if (value) {
      this.tags.push(["agent", JSON.stringify(value)]);
    }
  }
  /**
   * Template tags from 't' tags
   */
  get templateTags() {
    return this.getMatchingTags("t").map((tag) => tag[1]).filter(Boolean);
  }
  set templateTags(values) {
    this.tags = this.tags.filter((tag) => tag[0] !== "t");
    values.forEach((value) => {
      if (value) this.tags.push(["t", value]);
    });
  }
};

// src/events/gift-wrapping.ts
import { getEventHash as getEventHash2 } from "nostr-tools";

// src/events/kinds/simple-group/member-list.ts
var NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {
  relaySet;
  memberSet = /* @__PURE__ */ new Set();
  static kind = 39002 /* GroupMembers */;
  static kinds = [39002 /* GroupMembers */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 39002 /* GroupMembers */;
    this.memberSet = new Set(this.members);
  }
  static from(event) {
    return new _NDKSimpleGroupMemberList(event.ndk, event);
  }
  get members() {
    return this.getMatchingTags("p").map((tag) => tag[1]);
  }
  hasMember(member) {
    return this.memberSet.has(member);
  }
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    relaySet ??= this.relaySet;
    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);
  }
};

// src/events/kinds/simple-group/metadata.ts
var NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {
  static kind = 39e3 /* GroupMetadata */;
  static kinds = [39e3 /* GroupMetadata */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 39e3 /* GroupMetadata */;
  }
  static from(event) {
    return new _NDKSimpleGroupMetadata(event.ndk, event);
  }
  get name() {
    return this.tagValue("name");
  }
  get picture() {
    return this.tagValue("picture");
  }
  get about() {
    return this.tagValue("about");
  }
  get scope() {
    if (this.getMatchingTags("public").length > 0) return "public";
    if (this.getMatchingTags("public").length > 0) return "private";
    return void 0;
  }
  set scope(scope) {
    this.removeTag("public");
    this.removeTag("private");
    if (scope === "public") {
      this.tags.push(["public", ""]);
    } else if (scope === "private") {
      this.tags.push(["private", ""]);
    }
  }
  get access() {
    if (this.getMatchingTags("open").length > 0) return "open";
    if (this.getMatchingTags("closed").length > 0) return "closed";
    return void 0;
  }
  set access(access) {
    this.removeTag("open");
    this.removeTag("closed");
    if (access === "open") {
      this.tags.push(["open", ""]);
    } else if (access === "closed") {
      this.tags.push(["closed", ""]);
    }
  }
};

// src/relay/auth-policies.ts
import createDebug2 from "debug";
function disconnect(pool, debug9) {
  debug9 ??= createDebug2("ndk:relay:auth-policies:disconnect");
  return async (relay) => {
    debug9?.(`Relay ${relay.url} requested authentication, disconnecting`);
    pool.removeRelay(relay.url);
  };
}
async function signAndAuth(event, relay, signer, debug9, resolve, reject) {
  try {
    await event.sign(signer);
    resolve(event);
  } catch (e) {
    debug9?.(`Failed to publish auth event to relay ${relay.url}`, e);
    reject(event);
  }
}
function signIn({ ndk, signer, debug: debug9 } = {}) {
  debug9 ??= createDebug2("ndk:auth-policies:signIn");
  return async (relay, challenge) => {
    debug9?.(`Relay ${relay.url} requested authentication, signing in`);
    const event = new NDKEvent(ndk);
    event.kind = 22242 /* ClientAuth */;
    event.tags = [
      ["relay", relay.url],
      ["challenge", challenge]
    ];
    signer ??= ndk?.signer;
    return new Promise(async (resolve, reject) => {
      if (signer) {
        await signAndAuth(event, relay, signer, debug9, resolve, reject);
      } else {
        ndk?.once("signer:ready", async (signer2) => {
          await signAndAuth(event, relay, signer2, debug9, resolve, reject);
        });
      }
    });
  };
}
var NDKRelayAuthPolicies = {
  disconnect,
  signIn
};

// src/signers/nip07/index.ts
import debug6 from "debug";

// src/signers/registry.ts
var signerRegistry = /* @__PURE__ */ new Map();
function registerSigner(type, signerClass) {
  signerRegistry.set(type, signerClass);
}

// src/signers/nip07/index.ts
var NDKNip07Signer = class _NDKNip07Signer {
  _userPromise;
  encryptionQueue = [];
  encryptionProcessing = false;
  debug;
  waitTimeout;
  _pubkey;
  ndk;
  _user;
  /**
   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available
   */
  constructor(waitTimeout = 1e3, ndk) {
    this.debug = debug6("ndk:nip07");
    this.waitTimeout = waitTimeout;
    this.ndk = ndk;
  }
  get pubkey() {
    if (!this._pubkey) throw new Error("Not ready");
    return this._pubkey;
  }
  async blockUntilReady() {
    await this.waitForExtension();
    const pubkey = await window.nostr?.getPublicKey();
    if (!pubkey) {
      throw new Error("User rejected access");
    }
    this._pubkey = pubkey;
    let user;
    if (this.ndk) user = this.ndk.getUser({ pubkey });
    else user = new NDKUser({ pubkey });
    this._user = user;
    return user;
  }
  /**
   * Getter for the user property.
   * @returns The NDKUser instance.
   */
  async user() {
    if (!this._userPromise) {
      this._userPromise = this.blockUntilReady();
    }
    return this._userPromise;
  }
  get userSync() {
    if (!this._user) throw new Error("User not ready");
    return this._user;
  }
  /**
   * Signs the given Nostr event.
   * @param event - The Nostr event to be signed.
   * @returns The signature of the signed event.
   * @throws Error if the NIP-07 is not available on the window object.
   */
  async sign(event) {
    await this.waitForExtension();
    const signedEvent = await window.nostr?.signEvent(event);
    if (!signedEvent) throw new Error("Failed to sign event");
    return signedEvent.sig;
  }
  async relays(ndk) {
    await this.waitForExtension();
    const relays = await window.nostr?.getRelays?.() || {};
    const activeRelays = [];
    for (const url of Object.keys(relays)) {
      if (relays[url].read && relays[url].write) {
        activeRelays.push(url);
      }
    }
    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));
  }
  async encryptionEnabled(nip) {
    const enabled = [];
    if ((!nip || nip === "nip04") && Boolean(window.nostr?.nip04)) enabled.push("nip04");
    if ((!nip || nip === "nip44") && Boolean(window.nostr?.nip44)) enabled.push("nip44");
    return enabled;
  }
  async encrypt(recipient, value, nip = "nip04") {
    if (!await this.encryptionEnabled(nip))
      throw new Error(`${nip}encryption is not available from your browser extension`);
    await this.waitForExtension();
    const recipientHexPubKey = recipient.pubkey;
    return this.queueEncryption(nip, "encrypt", recipientHexPubKey, value);
  }
  async decrypt(sender, value, nip = "nip04") {
    if (!await this.encryptionEnabled(nip))
      throw new Error(`${nip}encryption is not available from your browser extension`);
    await this.waitForExtension();
    const senderHexPubKey = sender.pubkey;
    return this.queueEncryption(nip, "decrypt", senderHexPubKey, value);
  }
  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {
    return new Promise((resolve, reject) => {
      this.encryptionQueue.push({
        scheme,
        method,
        counterpartyHexpubkey,
        value,
        resolve,
        reject
      });
      if (!this.encryptionProcessing) {
        this.processEncryptionQueue();
      }
    });
  }
  async processEncryptionQueue(item, retries = 0) {
    if (!item && this.encryptionQueue.length === 0) {
      this.encryptionProcessing = false;
      return;
    }
    this.encryptionProcessing = true;
    const currentItem = item || this.encryptionQueue.shift();
    if (!currentItem) {
      this.encryptionProcessing = false;
      return;
    }
    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;
    this.debug("Processing encryption queue item", {
      method,
      counterpartyHexpubkey,
      value
    });
    try {
      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);
      if (!result) throw new Error("Failed to encrypt/decrypt");
      resolve(result);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("call already executing") && retries < 5) {
        this.debug("Retrying encryption queue item", {
          method,
          counterpartyHexpubkey,
          value,
          retries
        });
        setTimeout(() => {
          this.processEncryptionQueue(currentItem, retries + 1);
        }, 50 * retries);
        return;
      }
      reject(error instanceof Error ? error : new Error(errorMessage));
    }
    this.processEncryptionQueue();
  }
  waitForExtension() {
    return new Promise((resolve, reject) => {
      if (window.nostr) {
        resolve();
        return;
      }
      let timerId;
      const intervalId = setInterval(() => {
        if (window.nostr) {
          clearTimeout(timerId);
          clearInterval(intervalId);
          resolve();
        }
      }, 100);
      timerId = setTimeout(() => {
        clearInterval(intervalId);
        reject(new Error("NIP-07 extension not available"));
      }, this.waitTimeout);
    });
  }
  /**
   * Serializes the signer type into a storable format.
   * NIP-07 signers don't have persistent state to serialize beyond their type.
   * @returns A JSON string containing the type.
   */
  toPayload() {
    const payload = {
      type: "nip07",
      payload: ""
      // No specific payload needed for NIP-07
    };
    return JSON.stringify(payload);
  }
  /**
   * Deserializes the signer from a payload string.
   * Creates a new NDKNip07Signer instance.
   * @param payloadString The JSON string obtained from toPayload().
   * @param ndk Optional NDK instance.
   * @returns An instance of NDKNip07Signer.
   */
  static async fromPayload(payloadString, ndk) {
    const payload = JSON.parse(payloadString);
    if (payload.type !== "nip07") {
      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);
    }
    return new _NDKNip07Signer(void 0, ndk);
  }
};
registerSigner("nip07", NDKNip07Signer);

// src/signers/nip46/backend/index.ts
import { hexToBytes } from "@noble/hashes/utils";

// src/signers/nip46/rpc.ts
import { EventEmitter as EventEmitter5 } from "tseep";
var NDKNostrRpc = class extends EventEmitter5 {
  ndk;
  signer;
  relaySet;
  debug;
  encryptionType = "nip04";
  pool;
  constructor(ndk, signer, debug9, relayUrls) {
    super();
    this.ndk = ndk;
    this.signer = signer;
    if (relayUrls) {
      this.pool = new NDKPool(relayUrls, [], ndk, {
        debug: debug9.extend("rpc-pool"),
        name: "Nostr RPC"
      });
      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);
      for (const url of relayUrls) {
        const relay = this.pool.getRelay(url, false, false);
        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug9 });
        this.relaySet.addRelay(relay);
        relay.connect();
      }
    }
    this.debug = debug9.extend("rpc");
  }
  /**
   * Subscribe to a filter. This function will resolve once the subscription is ready.
   */
  subscribe(filter) {
    const sub = this.ndk.subscribe(
      filter,
      {
        closeOnEose: false,
        groupable: false,
        cacheUsage: "ONLY_RELAY" /* ONLY_RELAY */,
        pool: this.pool,
        relaySet: this.relaySet
      },
      false
    );
    sub.on("event", async (event) => {
      try {
        const parsedEvent = await this.parseEvent(event);
        if (parsedEvent.method) {
          this.emit("request", parsedEvent);
        } else {
          this.emit(`response-${parsedEvent.id}`, parsedEvent);
          this.emit("response", parsedEvent);
        }
      } catch (e) {
        this.debug("error parsing event", e, event.rawEvent());
      }
    });
    return new Promise((resolve) => {
      sub.on("eose", () => {
        this.debug("eosed");
        resolve(sub);
      });
      sub.start();
    });
  }
  async parseEvent(event) {
    if (this.encryptionType === "nip44" && event.content.includes("?iv=")) {
      this.encryptionType = "nip04";
    } else if (this.encryptionType === "nip04" && !event.content.includes("?iv=")) {
      this.encryptionType = "nip44";
    }
    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });
    remoteUser.ndk = this.ndk;
    let decryptedContent;
    try {
      decryptedContent = await this.signer.decrypt(
        remoteUser,
        event.content,
        this.encryptionType
      );
    } catch (_e) {
      const otherEncryptionType = this.encryptionType === "nip04" ? "nip44" : "nip04";
      decryptedContent = await this.signer.decrypt(
        remoteUser,
        event.content,
        otherEncryptionType
      );
      this.encryptionType = otherEncryptionType;
    }
    const parsedContent = JSON.parse(decryptedContent);
    const { id, method, params, result, error } = parsedContent;
    if (method) {
      return { id, pubkey: event.pubkey, method, params, event };
    }
    return { id, result, error, event };
  }
  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {
    const res = { id, result };
    if (error) {
      res.error = error;
    }
    const localUser = await this.signer.user();
    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });
    const event = new NDKEvent(this.ndk, {
      kind,
      content: JSON.stringify(res),
      tags: [["p", remotePubkey]],
      pubkey: localUser.pubkey
    });
    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);
    await event.sign(this.signer);
    await event.publish(this.relaySet);
  }
  /**
   * Sends a request.
   * @param remotePubkey
   * @param method
   * @param params
   * @param kind
   * @param id
   */
  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {
    const id = Math.random().toString(36).substring(7);
    const localUser = await this.signer.user();
    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });
    const request = { id, method, params };
    const promise = new Promise(() => {
      const responseHandler = (response) => {
        if (response.result === "auth_url") {
          this.once(`response-${id}`, responseHandler);
          this.emit("authUrl", response.error);
        } else if (cb) {
          cb(response);
        }
      };
      this.once(`response-${id}`, responseHandler);
    });
    const event = new NDKEvent(this.ndk, {
      kind,
      content: JSON.stringify(request),
      tags: [["p", remotePubkey]],
      pubkey: localUser.pubkey
    });
    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);
    await event.sign(this.signer);
    await event.publish(this.relaySet);
    return promise;
  }
};

// src/signers/nip46/index.ts
import { EventEmitter as EventEmitter6 } from "tseep";

// src/signers/deserialization.ts
async function ndkSignerFromPayload(payloadString, ndk) {
  let parsed;
  try {
    parsed = JSON.parse(payloadString);
  } catch (e) {
    console.error("Failed to parse signer payload string", payloadString, e);
    return void 0;
  }
  if (!parsed || typeof parsed.type !== "string") {
    console.error(
      "Failed to parse signer payload string",
      payloadString,
      new Error("Missing type field")
    );
    return void 0;
  }
  const SignerClass = signerRegistry.get(parsed.type);
  if (!SignerClass) {
    throw new Error(`Unknown signer type: ${parsed.type}`);
  }
  try {
    return await SignerClass.fromPayload(payloadString, ndk);
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);
  }
}

// src/signers/nip46/nostrconnect.ts
function nostrConnectGenerateSecret() {
  return Math.random().toString(36).substring(2, 15);
}
function generateNostrConnectUri(pubkey, secret, relay, options) {
  const meta = {
    name: options?.name ? encodeURIComponent(options.name) : "",
    url: options?.url ? encodeURIComponent(options.url) : "",
    image: options?.image ? encodeURIComponent(options.image) : "",
    perms: options?.perms ? encodeURIComponent(options.perms) : ""
  };
  let uri = `nostrconnect://${pubkey}?image=${meta.image}&url=${meta.url}&name=${meta.name}&perms=${meta.perms}&secret=${encodeURIComponent(secret)}`;
  if (relay) {
    uri += `&relay=${encodeURIComponent(relay)}`;
  }
  return uri;
}

// src/signers/nip46/index.ts
var NDKNip46Signer = class _NDKNip46Signer extends EventEmitter6 {
  ndk;
  _user;
  /**
   * The pubkey of the bunker that will be providing signatures
   */
  bunkerPubkey;
  /**
   * The pubkey of the user that events will be published as
   */
  userPubkey;
  get pubkey() {
    if (!this.userPubkey) throw new Error("Not ready");
    return this.userPubkey;
  }
  /**
   * An optional secret value provided to connect to the bunker
   */
  secret;
  localSigner;
  nip05;
  rpc;
  debug;
  relayUrls;
  subscription;
  /**
   * If using nostrconnect://, stores the nostrConnectURI
   */
  nostrConnectUri;
  /**
   * The random secret used for nostrconnect:// flows.
   */
  nostrConnectSecret;
  /**
   *
   * Don't instantiate this directly. Use the static methods instead.
   *
   * @example:
   * // for bunker:// flow
   * const signer = NDKNip46Signer.bunker(ndk, "bunker://<connection-token>")
   * const signer = NDKNip46Signer.bunker(ndk, "<your-nip05>"); // with nip05 flow
   * // for nostrconnect:// flow
   * const signer = NDKNip46Signer.nostrconnect(ndk, "wss://relay.example.com")
   *
   * @param ndk - The NDK instance to use
   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as
   * @param localSigner - The signer that will be used to request events to be signed
   */
  constructor(ndk, userOrConnectionToken, localSigner, relayUrls, nostrConnectOptions) {
    super();
    this.ndk = ndk;
    this.debug = ndk.debug.extend("nip46:signer");
    this.relayUrls = relayUrls;
    if (!localSigner) {
      this.localSigner = NDKPrivateKeySigner.generate();
    } else {
      if (typeof localSigner === "string") {
        this.localSigner = new NDKPrivateKeySigner(localSigner);
      } else {
        this.localSigner = localSigner;
      }
    }
    if (userOrConnectionToken === false) {
    } else if (!userOrConnectionToken) {
      this.nostrconnectFlowInit(nostrConnectOptions);
    } else if (userOrConnectionToken.startsWith("bunker://")) {
      this.bunkerFlowInit(userOrConnectionToken);
    } else {
      this.nip05Init(userOrConnectionToken);
    }
    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);
  }
  /**
   * Connnect with a bunker:// flow
   * @param ndk
   * @param userOrConnectionToken bunker:// connection string
   * @param localSigner If you have previously authenticated with this signer, you can restore the session by providing the previously authenticated key
   */
  static bunker(ndk, userOrConnectionToken, localSigner) {
    return new _NDKNip46Signer(ndk, userOrConnectionToken, localSigner);
  }
  /**
   * Connect with a nostrconnect:// flow
   * @param ndk
   * @param relay - Relay used to connect with the signer
   * @param localSigner If you have previously authenticated with this signer, you can restore the session by providing the previously authenticated key
   */
  static nostrconnect(ndk, relay, localSigner, nostrConnectOptions) {
    return new _NDKNip46Signer(ndk, void 0, localSigner, [relay], nostrConnectOptions);
  }
  nostrconnectFlowInit(nostrConnectOptions) {
    this.nostrConnectSecret = nostrConnectGenerateSecret();
    const pubkey = this.localSigner.pubkey;
    this.nostrConnectUri = generateNostrConnectUri(
      pubkey,
      this.nostrConnectSecret,
      this.relayUrls?.[0],
      nostrConnectOptions
    );
  }
  bunkerFlowInit(connectionToken) {
    const bunkerUrl = new URL(connectionToken);
    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\/\//, "");
    const userPubkey = bunkerUrl.searchParams.get("pubkey");
    const relayUrls = bunkerUrl.searchParams.getAll("relay");
    const secret = bunkerUrl.searchParams.get("secret");
    this.bunkerPubkey = bunkerPubkey;
    this.userPubkey = userPubkey;
    this.relayUrls = relayUrls;
    this.secret = secret;
  }
  nip05Init(nip05) {
    this.nip05 = nip05;
  }
  /**
   * We start listening for events from the bunker
   */
  async startListening() {
    if (this.subscription) return;
    const localUser = await this.localSigner.user();
    if (!localUser) throw new Error("Local signer not ready");
    this.subscription = await this.rpc.subscribe({
      kinds: [24133 /* NostrConnect */],
      "#p": [localUser.pubkey]
    });
  }
  /**
   * Get the user that is being published as
   */
  async user() {
    if (this._user) return this._user;
    return this.blockUntilReady();
  }
  get userSync() {
    if (!this._user) throw new Error("Remote user not ready synchronously");
    return this._user;
  }
  async blockUntilReadyNostrConnect() {
    return new Promise((resolve, reject) => {
      const connect = (response) => {
        if (response.result === this.nostrConnectSecret) {
          this._user = response.event.author;
          this.userPubkey = response.event.pubkey;
          this.bunkerPubkey = response.event.pubkey;
          this.rpc.off("response", connect);
          resolve(this._user);
        }
      };
      this.startListening();
      this.rpc.on("response", connect);
    });
  }
  async blockUntilReady() {
    if (!this.bunkerPubkey && !this.nostrConnectSecret && !this.nip05) {
      throw new Error("Bunker pubkey not set");
    }
    if (this.nostrConnectSecret) return this.blockUntilReadyNostrConnect();
    if (this.nip05 && !this.userPubkey) {
      const user = await NDKUser.fromNip05(this.nip05, this.ndk);
      if (user) {
        this._user = user;
        this.userPubkey = user.pubkey;
        this.relayUrls = user.nip46Urls;
        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);
      }
    }
    if (!this.bunkerPubkey && this.userPubkey) {
      this.bunkerPubkey = this.userPubkey;
    } else if (!this.bunkerPubkey) {
      throw new Error("Bunker pubkey not set");
    }
    await this.startListening();
    this.rpc.on("authUrl", (...props) => {
      this.emit("authUrl", ...props);
    });
    return new Promise((resolve, reject) => {
      const connectParams = [this.userPubkey ?? ""];
      if (this.secret) connectParams.push(this.secret);
      if (!this.bunkerPubkey) throw new Error("Bunker pubkey not set");
      this.rpc.sendRequest(
        this.bunkerPubkey,
        "connect",
        connectParams,
        24133,
        (response) => {
          if (response.result === "ack") {
            this.getPublicKey().then((pubkey) => {
              this.userPubkey = pubkey;
              this._user = this.ndk.getUser({ pubkey });
              resolve(this._user);
            });
          } else {
            reject(response.error);
          }
        }
      );
    });
  }
  stop() {
    this.subscription?.stop();
    this.subscription = void 0;
  }
  async getPublicKey() {
    if (this.userPubkey) return this.userPubkey;
    return new Promise((resolve, _reject) => {
      if (!this.bunkerPubkey) throw new Error("Bunker pubkey not set");
      this.rpc.sendRequest(
        this.bunkerPubkey,
        "get_public_key",
        [],
        24133,
        (response) => {
          resolve(response.result);
        }
      );
    });
  }
  async encryptionEnabled(scheme) {
    if (scheme) return [scheme];
    return Promise.resolve(["nip04", "nip44"]);
  }
  async encrypt(recipient, value, scheme = "nip04") {
    return this.encryption(recipient, value, scheme, "encrypt");
  }
  async decrypt(sender, value, scheme = "nip04") {
    return this.encryption(sender, value, scheme, "decrypt");
  }
  async encryption(peer, value, scheme, method) {
    const promise = new Promise((resolve, reject) => {
      if (!this.bunkerPubkey) throw new Error("Bunker pubkey not set");
      this.rpc.sendRequest(
        this.bunkerPubkey,
        `${scheme}_${method}`,
        [peer.pubkey, value],
        24133,
        (response) => {
          if (!response.error) {
            resolve(response.result);
          } else {
            reject(response.error);
          }
        }
      );
    });
    return promise;
  }
  async sign(event) {
    const promise = new Promise((resolve, reject) => {
      if (!this.bunkerPubkey) throw new Error("Bunker pubkey not set");
      this.rpc.sendRequest(
        this.bunkerPubkey,
        "sign_event",
        [JSON.stringify(event)],
        24133,
        (response) => {
          if (!response.error) {
            const json = JSON.parse(response.result);
            resolve(json.sig);
          } else {
            reject(response.error);
          }
        }
      );
    });
    return promise;
  }
  /**
   * Allows creating a new account on the remote server.
   * @param username Desired username for the NIP-05
   * @param domain Desired domain for the NIP-05
   * @param email Email address to associate with this account -- Remote servers may use this for recovery
   * @returns The public key of the newly created account
   */
  async createAccount(username, domain, email) {
    await this.startListening();
    const req = [];
    if (username) req.push(username);
    if (domain) req.push(domain);
    if (email) req.push(email);
    return new Promise((resolve, reject) => {
      if (!this.bunkerPubkey) throw new Error("Bunker pubkey not set");
      this.rpc.sendRequest(
        this.bunkerPubkey,
        "create_account",
        req,
        24133 /* NostrConnect */,
        (response) => {
          if (!response.error) {
            const pubkey = response.result;
            resolve(pubkey);
          } else {
            reject(response.error);
          }
        }
      );
    });
  }
  /**
   * Serializes the signer's connection details and local signer state.
   * @returns A JSON string containing the type, connection info, and local signer payload.
   */
  toPayload() {
    if (!this.bunkerPubkey || !this.userPubkey) {
      throw new Error("NIP-46 signer is not fully initialized for serialization");
    }
    const payload = {
      type: "nip46",
      payload: {
        bunkerPubkey: this.bunkerPubkey,
        userPubkey: this.userPubkey,
        relayUrls: this.relayUrls,
        secret: this.secret,
        localSignerPayload: this.localSigner.toPayload(),
        // Store nip05 if it was used for initialization, otherwise null
        nip05: this.nip05 || null
      }
    };
    return JSON.stringify(payload);
  }
  /**
   * Deserializes the signer from a payload string.
   * @param payloadString The JSON string obtained from toPayload().
   * @param ndk The NDK instance, required for NIP-46.
   * @returns An instance of NDKNip46Signer.
   */
  static async fromPayload(payloadString, ndk) {
    if (!ndk) {
      throw new Error("NDK instance is required to deserialize NIP-46 signer");
    }
    const parsed = JSON.parse(payloadString);
    if (parsed.type !== "nip46") {
      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);
    }
    const payload = parsed.payload;
    if (!payload || typeof payload !== "object" || !payload.localSignerPayload) {
      throw new Error("Invalid payload content for nip46 signer");
    }
    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);
    if (!localSigner) {
      throw new Error("Failed to deserialize local signer for NIP-46");
    }
    if (!(localSigner instanceof NDKPrivateKeySigner)) {
      throw new Error("Local signer must be an instance of NDKPrivateKeySigner");
    }
    let signer;
    signer = new _NDKNip46Signer(ndk, false, localSigner, payload.relayUrls);
    signer.userPubkey = payload.userPubkey;
    signer.bunkerPubkey = payload.bunkerPubkey;
    signer.relayUrls = payload.relayUrls;
    signer.secret = payload.secret;
    if (payload.userPubkey) {
      signer._user = new NDKUser({ pubkey: payload.userPubkey });
      if (signer._user) signer._user.ndk = ndk;
    }
    return signer;
  }
};
registerSigner("nip46", NDKNip46Signer);

// src/subscription/utils.ts
import { nip19 as nip194 } from "nostr-tools";
function queryFullyFilled(subscription) {
  if (filterIncludesIds(subscription.filter)) {
    if (resultHasAllRequestedIds(subscription)) {
      return true;
    }
  }
  return false;
}
function filterIncludesIds(filter) {
  return !!filter.ids;
}
function resultHasAllRequestedIds(subscription) {
  const ids = subscription.filter.ids;
  return !!ids && ids.length === subscription.eventFirstSeen.size;
}
function filterFromId(id) {
  let decoded;
  if (id.match(NIP33_A_REGEX)) {
    const [kind, pubkey, identifier] = id.split(":");
    const filter = {
      authors: [pubkey],
      kinds: [Number.parseInt(kind)]
    };
    if (identifier) {
      filter["#d"] = [identifier];
    }
    return filter;
  }
  if (id.match(BECH32_REGEX)) {
    try {
      decoded = nip194.decode(id);
      switch (decoded.type) {
        case "nevent": {
          const filter = { ids: [decoded.data.id] };
          if (decoded.data.author) filter.authors = [decoded.data.author];
          if (decoded.data.kind) filter.kinds = [decoded.data.kind];
          return filter;
        }
        case "note":
          return { ids: [decoded.data] };
        case "naddr": {
          const filter = {
            authors: [decoded.data.pubkey],
            kinds: [decoded.data.kind]
          };
          if (decoded.data.identifier) filter["#d"] = [decoded.data.identifier];
          return filter;
        }
      }
    } catch (e) {
      console.error("Error decoding", id, e);
    }
  }
  return { ids: [id] };
}
function isNip33AValue(value) {
  return value.match(NIP33_A_REGEX) !== null;
}
var NIP33_A_REGEX = /^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/;
var BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\d\w]+$/;
function relaysFromBech32(bech322, ndk) {
  try {
    const decoded = nip194.decode(bech322);
    if (["naddr", "nevent"].includes(decoded?.type)) {
      const data = decoded.data;
      if (data?.relays) {
        return data.relays.map(
          (r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk)
        );
      }
    }
  } catch (_e) {
  }
  return [];
}

// src/user/profile.ts
function profileFromEvent(event) {
  const profile = {};
  let payload;
  try {
    payload = JSON.parse(event.content);
  } catch (error) {
    throw new Error(`Failed to parse profile event: ${error}`);
  }
  profile.profileEvent = JSON.stringify(event.rawEvent());
  for (const key of Object.keys(payload)) {
    switch (key) {
      case "name":
        profile.name = payload.name;
        break;
      case "display_name":
        profile.displayName = payload.display_name;
        break;
      case "image":
      case "picture":
        profile.picture = payload.picture || payload.image;
        profile.image = profile.picture;
        break;
      case "banner":
        profile.banner = payload.banner;
        break;
      case "bio":
        profile.bio = payload.bio;
        break;
      case "nip05":
        profile.nip05 = payload.nip05;
        break;
      case "lud06":
        profile.lud06 = payload.lud06;
        break;
      case "lud16":
        profile.lud16 = payload.lud16;
        break;
      case "about":
        profile.about = payload.about;
        break;
      case "website":
        profile.website = payload.website;
        break;
      default:
        profile[key] = payload[key];
        break;
    }
  }
  profile.created_at = event.created_at;
  return profile;
}
function serializeProfile(profile) {
  const payload = {};
  for (const [key, val] of Object.entries(profile)) {
    switch (key) {
      case "username":
      case "name":
        payload.name = val;
        break;
      case "displayName":
        payload.display_name = val;
        break;
      case "image":
      case "picture":
        payload.picture = val;
        break;
      case "bio":
      case "about":
        payload.about = val;
        break;
      default:
        payload[key] = val;
        break;
    }
  }
  return JSON.stringify(payload);
}

// src/ndk/index.ts
import debug8 from "debug";
import { EventEmitter as EventEmitter8 } from "tseep";

// src/events/dedup.ts
function dedup(event1, event2) {
  if (event1.created_at > event2.created_at) {
    return event1;
  }
  return event2;
}

// src/outbox/tracker.ts
import { EventEmitter as EventEmitter7 } from "tseep";
import { LRUCache as LRUCache2 } from "typescript-lru-cache";

// src/utils/get-users-relay-list.ts
async function getRelayListForUser(pubkey, ndk) {
  const list = await getRelayListForUsers([pubkey], ndk);
  return list.get(pubkey);
}
async function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {
  const pool = ndk.outboxPool || ndk.pool;
  const set = /* @__PURE__ */ new Set();
  for (const relay of pool.relays.values()) set.add(relay);
  const relayLists = /* @__PURE__ */ new Map();
  const fromContactList = /* @__PURE__ */ new Map();
  const relaySet = new NDKRelaySet(set, ndk);
  if (ndk.cacheAdapter?.locking && !skipCache) {
    const cachedList = await ndk.fetchEvents(
      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },
      { cacheUsage: "ONLY_CACHE" /* ONLY_CACHE */, subId: "ndk-relay-list-fetch" }
    );
    for (const relayList of cachedList) {
      if (relayList.kind === 10002)
        relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));
    }
    for (const relayList of cachedList) {
      if (relayList.kind === 3) {
        if (relayLists.has(relayList.pubkey)) continue;
        const list = relayListFromKind3(ndk, relayList);
        if (list) fromContactList.set(relayList.pubkey, list);
      }
    }
    pubkeys = pubkeys.filter(
      (pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey)
    );
  }
  if (pubkeys.length === 0) return relayLists;
  const relayListEvents = /* @__PURE__ */ new Map();
  const contactListEvents = /* @__PURE__ */ new Map();
  return new Promise((resolve) => {
    const handleSubscription = async () => {
      const subscribeOpts = {
        closeOnEose: true,
        pool,
        groupable: true,
        subId: "ndk-relay-list-fetch",
        addSinceFromCache: true,
        relaySet
      };
      if (relaySet) subscribeOpts.relaySet = relaySet;
      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {
        onEvent: (event) => {
          if (event.kind === 10002 /* RelayList */) {
            const existingEvent = relayListEvents.get(event.pubkey);
            if (existingEvent && existingEvent.created_at > event.created_at) return;
            relayListEvents.set(event.pubkey, event);
          } else if (event.kind === 3 /* Contacts */) {
            const existingEvent = contactListEvents.get(event.pubkey);
            if (existingEvent && existingEvent.created_at > event.created_at) return;
            contactListEvents.set(event.pubkey, event);
          }
        },
        onEose: () => {
          for (const event of relayListEvents.values()) {
            relayLists.set(event.pubkey, NDKRelayList.from(event));
          }
          for (const pubkey of pubkeys) {
            if (relayLists.has(pubkey)) continue;
            const contactList = contactListEvents.get(pubkey);
            if (!contactList) continue;
            const list = relayListFromKind3(ndk, contactList);
            if (list) relayLists.set(pubkey, list);
          }
          resolve(relayLists);
        }
      });
      setTimeout(() => {
        resolve(relayLists);
      }, timeout);
    };
    handleSubscription();
  });
}

// src/outbox/tracker.ts
var OutboxItem = class {
  /**
   * Type of item
   */
  type;
  /**
   * The relay URLs that are of interest to this item
   */
  relayUrlScores;
  readRelays;
  writeRelays;
  constructor(type) {
    this.type = type;
    this.relayUrlScores = /* @__PURE__ */ new Map();
    this.readRelays = /* @__PURE__ */ new Set();
    this.writeRelays = /* @__PURE__ */ new Set();
  }
};
var OutboxTracker = class extends EventEmitter7 {
  data;
  ndk;
  debug;
  constructor(ndk) {
    super();
    this.ndk = ndk;
    this.debug = ndk.debug.extend("outbox-tracker");
    this.data = new LRUCache2({
      maxSize: 1e5,
      entryExpirationTimeInMS: 2 * 60 * 1e3
    });
  }
  /**
   * Adds a list of users to the tracker.
   * @param items
   * @param skipCache
   */
  async trackUsers(items, skipCache = false) {
    const promises = [];
    for (let i = 0; i < items.length; i += 400) {
      const slice = items.slice(i, i + 400);
      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));
      if (pubkeys.length === 0) continue;
      for (const pubkey of pubkeys) {
        this.data.set(pubkey, new OutboxItem("user"));
      }
      promises.push(
        new Promise((resolve) => {
          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {
            for (const [pubkey, relayList] of relayLists) {
              let outboxItem = this.data.get(pubkey);
              outboxItem ??= new OutboxItem("user");
              if (relayList) {
                outboxItem.readRelays = new Set(
                  normalize(relayList.readRelayUrls)
                );
                outboxItem.writeRelays = new Set(
                  normalize(relayList.writeRelayUrls)
                );
                for (const relayUrl of outboxItem.readRelays) {
                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {
                    outboxItem.readRelays.delete(relayUrl);
                  }
                }
                for (const relayUrl of outboxItem.writeRelays) {
                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {
                    outboxItem.writeRelays.delete(relayUrl);
                  }
                }
                this.data.set(pubkey, outboxItem);
              }
            }
          }).finally(resolve);
        })
      );
    }
    return Promise.all(promises);
  }
  /**
   *
   * @param key
   * @param score
   */
  track(item, type, _skipCache = true) {
    const key = getKeyFromItem(item);
    type ??= getTypeFromItem(item);
    let outboxItem = this.data.get(key);
    if (!outboxItem) {
      outboxItem = new OutboxItem(type);
      if (item instanceof NDKUser) {
        this.trackUsers([item]);
      }
    }
    return outboxItem;
  }
};
function getKeyFromItem(item) {
  if (item instanceof NDKUser) {
    return item.pubkey;
  }
  return item;
}
function getTypeFromItem(item) {
  if (item instanceof NDKUser) {
    return "user";
  }
  return "kind";
}

// src/relay/sets/utils.ts
function correctRelaySet(relaySet, pool) {
  const connectedRelays = pool.connectedRelays();
  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {
    return connectedRelays.map((r) => r.url).includes(relay.url);
  });
  if (!includesConnectedRelay) {
    for (const relay of connectedRelays) {
      relaySet.addRelay(relay);
    }
  }
  if (connectedRelays.length === 0) {
    for (const relay of pool.relays.values()) {
      relaySet.addRelay(relay);
    }
  }
  return relaySet;
}

// src/subscription/manager.ts
import { matchFilters } from "nostr-tools";
var NDKSubscriptionManager = class {
  subscriptions;
  seenEvents = /* @__PURE__ */ new Map();
  constructor() {
    this.subscriptions = /* @__PURE__ */ new Map();
  }
  add(sub) {
    this.subscriptions.set(sub.internalId, sub);
    if (sub.onStopped) {
    }
    sub.onStopped = () => {
      this.subscriptions.delete(sub.internalId);
    };
    sub.on("close", () => {
      this.subscriptions.delete(sub.internalId);
    });
  }
  seenEvent(eventId, relay) {
    const current = this.seenEvents.get(eventId) || [];
    current.push(relay);
    this.seenEvents.set(eventId, current);
  }
  /**
   * Whenever an event comes in, this function is called.
   * This function matches the received event against all the
   * known (i.e. active) NDKSubscriptions, and if it matches,
   * it sends the event to the subscription.
   *
   * This is the single place in the codebase that matches
   * incoming events with parties interested in the event.
   *
   * This is also what allows for reactivity in NDK apps, such that
   * whenever an active subscription receives an event that some
   * other active subscription would want to receive, both receive it.
   *
   * TODO This also allows for subscriptions that overlap in meaning
   * to be collapsed into one.
   *
   * I.e. if a subscription with filter: kinds: [1], authors: [alice]
   * is created and EOSEs, and then a subsequent subscription with
   * kinds: [1], authors: [alice] is created, once the second subscription
   * EOSEs we can safely close it, increment its refCount and close it,
   * and when the first subscription receives a new event from Alice this
   * code will make the second subscription receive the event even though
   * it has no active subscription on a relay.
   * @param event Raw event received from a relay
   * @param relay Relay that sent the event
   * @param optimisticPublish Whether the event is coming from an optimistic publish
   */
  dispatchEvent(event, relay, optimisticPublish = false) {
    if (relay) this.seenEvent(event.id, relay);
    const subscriptions = this.subscriptions.values();
    const matchingSubs = [];
    for (const sub of subscriptions) {
      if (matchFilters(sub.filters, event)) {
        matchingSubs.push(sub);
      }
    }
    for (const sub of matchingSubs) {
      sub.eventReceived(event, relay, false, optimisticPublish);
    }
  }
};

// src/ndk/active-user.ts
import createDebug3 from "debug";
var debug7 = createDebug3("ndk:active-user");
async function getUserRelayList(user) {
  if (!this.autoConnectUserRelays) return;
  const userRelays = await getRelayListForUser(user.pubkey, this);
  if (!userRelays) return;
  for (const url of userRelays.relays) {
    let relay = this.pool.relays.get(url);
    if (!relay) {
      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);
      this.pool.addRelay(relay);
    }
  }
  return userRelays;
}
async function setActiveUser(user) {
  const pool = this.outboxPool || this.pool;
  if (pool.connectedRelays.length > 0) {
    setActiveUserConnected.call(this, user);
  } else {
    pool.once("connect", () => {
      setActiveUserConnected.call(this, user);
    });
  }
}
async function setActiveUserConnected(user) {
  const userRelays = await getUserRelayList.call(this, user);
  const filters = [
    {
      kinds: [10006 /* BlockRelayList */],
      authors: [user.pubkey]
    }
  ];
  if (this.autoFetchUserMutelist) {
    filters[0].kinds?.push(1e4 /* MuteList */);
  }
  const events = /* @__PURE__ */ new Map();
  const relaySet = userRelays ? userRelays.relaySet : void 0;
  this.subscribe(
    filters,
    { subId: "active-user-settings", closeOnEose: true, relaySet },
    {
      onEvent: (event) => {
        const prevEvent = events.get(event.kind);
        if (prevEvent && prevEvent.created_at >= event.created_at) return;
        events.set(event.kind, event);
      },
      onEose: () => {
        for (const event of events.values()) {
          processEvent.call(this, event);
        }
      }
    }
  );
}
async function processEvent(event) {
  if (event.kind === 10006 /* BlockRelayList */) {
    processBlockRelayList.call(this, event);
  } else if (event.kind === 1e4 /* MuteList */) {
    processMuteList.call(this, event);
  }
}
function processBlockRelayList(event) {
  const list = lists_default.from(event);
  for (const item of list.items) {
    this.pool.blacklistRelayUrls.add(item[0]);
  }
  debug7("Added %d relays to relay blacklist", list.items.length);
}
function processMuteList(muteList) {
  const list = lists_default.from(muteList);
  for (const item of list.items) {
    this.mutedIds.set(item[1], item[0]);
  }
  debug7("Added %d users to mute list", list.items.length);
}

// src/ndk/entity.ts
import { nip19 as nip195 } from "nostr-tools";
function getEntity(entity) {
  try {
    const decoded = nip195.decode(entity);
    if (decoded.type === "npub") return npub(this, decoded.data);
    if (decoded.type === "nprofile") return nprofile(this, decoded.data);
    return decoded;
  } catch (_e) {
    return null;
  }
}
function npub(ndk, pubkey) {
  return ndk.getUser({ pubkey });
}
function nprofile(ndk, profile) {
  const user = ndk.getUser({ pubkey: profile.pubkey });
  if (profile.relays) user.relayUrls = profile.relays;
  return user;
}

// src/ndk/fetch-event-from-tag.ts
function isValidHint(hint) {
  if (!hint || hint === "") return false;
  try {
    new URL(hint);
    return true;
  } catch (_e) {
    return false;
  }
}
async function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {
  type: "timeout"
}) {
  const d4 = this.debug.extend("fetch-event-from-tag");
  const [_, id, hint] = tag;
  subOpts = {};
  d4("fetching event from tag", tag, subOpts, fallback);
  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);
  if (authorRelays && authorRelays.size > 0) {
    d4("fetching event from author relays %o", Array.from(authorRelays));
    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);
    const event2 = await this.fetchEvent(id, subOpts, relaySet2);
    if (event2) return event2;
  } else {
    d4("no author relays found for %s", originalEvent.pubkey, originalEvent);
  }
  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);
  d4("fetching event without relay hint", relaySet);
  const event = await this.fetchEvent(id, subOpts);
  if (event) return event;
  if (hint && hint !== "") {
    const event2 = await this.fetchEvent(
      id,
      subOpts,
      this.pool.getRelay(hint, true, true, [{ ids: [id] }])
    );
    if (event2) return event2;
  }
  let result = void 0;
  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;
  const fetchMaybeWithRelayHint = new Promise((resolve) => {
    this.fetchEvent(id, subOpts, relay).then(resolve);
  });
  if (!isValidHint(hint) || fallback.type === "none") {
    return fetchMaybeWithRelayHint;
  }
  const fallbackFetchPromise = new Promise(async (resolve) => {
    const fallbackRelaySet = fallback.relaySet;
    const timeout = fallback.timeout ?? 1500;
    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));
    if (fallback.type === "timeout") await timeoutPromise;
    if (result) {
      resolve(result);
    } else {
      d4("fallback fetch triggered");
      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);
      resolve(fallbackEvent);
    }
  });
  switch (fallback.type) {
    case "timeout":
      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);
    case "eose":
      result = await fetchMaybeWithRelayHint;
      if (result) return result;
      return fallbackFetchPromise;
  }
}

// src/ndk/queue/index.ts
var Queue = class {
  queue = [];
  maxConcurrency;
  processing = /* @__PURE__ */ new Set();
  promises = /* @__PURE__ */ new Map();
  constructor(_name, maxConcurrency) {
    this.maxConcurrency = maxConcurrency;
  }
  add(item) {
    if (this.promises.has(item.id)) {
      return this.promises.get(item.id);
    }
    const promise = new Promise((resolve, reject) => {
      this.queue.push({
        ...item,
        func: () => item.func().then(
          (result) => {
            resolve(result);
            return result;
          },
          (error) => {
            reject(error);
            throw error;
          }
        )
      });
      this.process();
    });
    this.promises.set(item.id, promise);
    promise.finally(() => {
      this.promises.delete(item.id);
      this.processing.delete(item.id);
      this.process();
    });
    return promise;
  }
  process() {
    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {
      return;
    }
    const item = this.queue.shift();
    if (!item || this.processing.has(item.id)) {
      return;
    }
    this.processing.add(item.id);
    item.func();
  }
  clear() {
    this.queue = [];
  }
  clearProcessing() {
    this.processing.clear();
  }
  clearAll() {
    this.clear();
    this.clearProcessing();
  }
  length() {
    return this.queue.length;
  }
};

// src/ndk/index.ts
var DEFAULT_OUTBOX_RELAYS = ["wss://purplepag.es/", "wss://nos.lol/"];
var DEFAULT_BLACKLISTED_RELAYS = [
  "wss://brb.io/",
  // BRB
  "wss://nostr.mutinywallet.com/"
  // Don't try to read from this relay since it's a write-only relay
  // "wss://purplepag.es/", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds
];
var NDK = class extends EventEmitter8 {
  _explicitRelayUrls;
  blacklistRelayUrls;
  pool;
  outboxPool;
  _signer;
  _activeUser;
  cacheAdapter;
  debug;
  devWriteRelaySet;
  outboxTracker;
  mutedIds;
  clientName;
  clientNip89;
  queuesZapConfig;
  queuesNip05;
  asyncSigVerification = false;
  initialValidationRatio = 1;
  lowestValidationRatio = 0.1;
  validationRatioFn;
  autoBlacklistInvalidRelays = false;
  subManager;
  /**
   * Private storage for the signature verification function
   */
  _signatureVerificationFunction;
  /**
   * Private storage for the signature verification worker
   */
  _signatureVerificationWorker;
  /**
   * Rolling total of time spent (in ms) performing signature verifications.
   * Users can read this to monitor or display aggregate verification cost.
   */
  signatureVerificationTimeMs = 0;
  publishingFailureHandled = false;
  pools = [];
  /**
   * Default relay-auth policy that will be used when a relay requests authentication,
   * if no other policy is specified for that relay.
   *
   * @example Disconnect from relays that request authentication:
   * ```typescript
   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);
   * ```
   *
   * @example Sign in to relays that request authentication:
   * ```typescript
   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})
   * ```
   *
   * @example Sign in to relays that request authentication, asking the user for confirmation:
   * ```typescript
   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {
   *     const signIn = NDKAuthPolicies.signIn({ndk});
   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {
   *        signIn(relay);
   *     }
   * }
   * ```
   */
  relayAuthDefaultPolicy;
  /**
   * Fetch function to use for HTTP requests.
   *
   * @example
   * ```typescript
   * import fetch from "node-fetch";
   *
   * ndk.httpFetch = fetch;
   * ```
   */
  httpFetch;
  /**
   * Provide a caller function to receive all networking traffic from relays
   */
  netDebug;
  autoConnectUserRelays = true;
  autoFetchUserMutelist = true;
  walletConfig;
  constructor(opts = {}) {
    super();
    this.debug = opts.debug || debug8("ndk");
    this.netDebug = opts.netDebug;
    this._explicitRelayUrls = opts.explicitRelayUrls || [];
    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;
    this.subManager = new NDKSubscriptionManager();
    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);
    this.pool.name = "Main";
    this.pool.on("relay:auth", async (relay, challenge) => {
      if (this.relayAuthDefaultPolicy) {
        await this.relayAuthDefaultPolicy(relay, challenge);
      }
    });
    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;
    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;
    this.clientName = opts.clientName;
    this.clientNip89 = opts.clientNip89;
    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;
    if (opts.enableOutboxModel) {
      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {
        debug: this.debug.extend("outbox-pool"),
        name: "Outbox Pool"
      });
      this.outboxTracker = new OutboxTracker(this);
    }
    this.signer = opts.signer;
    this.cacheAdapter = opts.cacheAdapter;
    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();
    if (opts.devWriteRelayUrls) {
      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);
    }
    this.queuesZapConfig = new Queue("zaps", 3);
    this.queuesNip05 = new Queue("nip05", 10);
    if (opts.signatureVerificationWorker) {
      this.signatureVerificationWorker = opts.signatureVerificationWorker;
    }
    if (opts.signatureVerificationFunction) {
      this.signatureVerificationFunction = opts.signatureVerificationFunction;
    }
    this.initialValidationRatio = opts.initialValidationRatio || 1;
    this.lowestValidationRatio = opts.lowestValidationRatio || 0.1;
    this.autoBlacklistInvalidRelays = opts.autoBlacklistInvalidRelays || false;
    this.validationRatioFn = opts.validationRatioFn || this.defaultValidationRatioFn;
    try {
      this.httpFetch = fetch;
    } catch {
    }
  }
  set explicitRelayUrls(urls) {
    this._explicitRelayUrls = urls.map(normalizeRelayUrl);
    this.pool.relayUrls = urls;
  }
  get explicitRelayUrls() {
    return this._explicitRelayUrls || [];
  }
  /**
   * Set a Web Worker for signature verification.
   *
   * This method initializes the worker and sets the asyncSigVerification flag.
   * The actual verification is handled by the verifySignatureAsync function in signature.ts,
   * which will use the worker if available.
   */
  set signatureVerificationWorker(worker2) {
    this._signatureVerificationWorker = worker2;
    if (worker2) {
      signatureVerificationInit(worker2);
      this.asyncSigVerification = true;
    } else {
      this.asyncSigVerification = false;
    }
  }
  /**
   * Set a custom signature verification function.
   *
   * This method is particularly useful for platforms that don't support Web Workers,
   * such as React Native.
   *
   * When a function is provided, it will be used for signature verification
   * instead of the default worker-based verification. This enables signature
   * verification on platforms where Web Workers are not available.
   *
   * @example
   * ```typescript
   * import { verifySignatureAsync } from "@nostr-dev-kit/ndk-mobile";
   *
   * ndk.signatureVerificationFunction = verifySignatureAsync;
   * ```
   */
  set signatureVerificationFunction(fn) {
    this._signatureVerificationFunction = fn;
    this.asyncSigVerification = !!fn;
  }
  /**
   * Get the custom signature verification function
   */
  get signatureVerificationFunction() {
    return this._signatureVerificationFunction;
  }
  /**
   * Adds an explicit relay to the pool.
   * @param url
   * @param relayAuthPolicy Authentication policy to use if different from the default
   * @param connect Whether to connect to the relay automatically
   * @returns
   */
  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {
    let relay;
    if (typeof urlOrRelay === "string") {
      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);
    } else {
      relay = urlOrRelay;
    }
    this.pool.addRelay(relay, connect);
    this.explicitRelayUrls?.push(relay.url);
    return relay;
  }
  toJSON() {
    return { relayCount: this.pool.relays.size }.toString();
  }
  get activeUser() {
    return this._activeUser;
  }
  /**
   * Sets the active user for this NDK instance, typically this will be
   * called when assigning a signer to the NDK instance.
   *
   * This function will automatically connect to the user's relays if
   * `autoConnectUserRelays` is set to true.
   *
   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.
   */
  set activeUser(user) {
    const differentUser = this._activeUser?.pubkey !== user?.pubkey;
    this._activeUser = user;
    if (user && differentUser) {
      setActiveUser.call(this, user);
    } else if (!user) {
      this.mutedIds = /* @__PURE__ */ new Map();
    }
  }
  get signer() {
    return this._signer;
  }
  set signer(newSigner) {
    this._signer = newSigner;
    if (newSigner) this.emit("signer:ready", newSigner);
    newSigner?.user().then((user) => {
      user.ndk = this;
      this.activeUser = user;
    });
  }
  /**
   * Connect to relays with optional timeout.
   * If the timeout is reached, the connection will be continued to be established in the background.
   */
  async connect(timeoutMs) {
    if (this._signer && this.autoConnectUserRelays) {
      this.debug(
        "Attempting to connect to user relays specified by signer %o",
        await this._signer.relays?.(this)
      );
      if (this._signer.relays) {
        const relays = await this._signer.relays(this);
        relays.forEach((relay) => this.pool.addRelay(relay));
      }
    }
    const connections = [this.pool.connect(timeoutMs)];
    if (this.outboxPool) {
      connections.push(this.outboxPool.connect(timeoutMs));
    }
    return Promise.allSettled(connections).then(() => {
    });
  }
  /**
   * Centralized method to report an invalid signature, identifying the relay that provided it.
   * A single invalid signature means the relay is considered malicious.
   * All invalid signature detections (synchronous or asynchronous) should delegate to this method.
   *
   * @param event The event with an invalid signature
   * @param relay The relay that provided the invalid signature
   */
  reportInvalidSignature(event, relay) {
    this.debug(
      `Invalid signature detected for event ${event.id}${relay ? ` from relay ${relay.url}` : ""}`
    );
    this.emit("event:invalid-sig", event, relay);
    if (this.autoBlacklistInvalidRelays && relay) {
      this.blacklistRelay(relay.url);
    }
  }
  /**
   * Add a relay URL to the blacklist as it has been identified as malicious
   */
  blacklistRelay(url) {
    if (!this.blacklistRelayUrls) {
      this.blacklistRelayUrls = [];
    }
    if (!this.blacklistRelayUrls.includes(url)) {
      this.blacklistRelayUrls.push(url);
      this.debug(`Added relay to blacklist: ${url}`);
      const relay = this.pool.getRelay(url, false, false);
      if (relay) {
        relay.disconnect();
        this.debug(`Disconnected from blacklisted relay: ${url}`);
      }
    }
  }
  /**
   * Default function to calculate validation ratio based on historical validation results.
   * The more events validated successfully, the lower the ratio goes (down to the minimum).
   */
  defaultValidationRatioFn(relay, validatedCount, nonValidatedCount) {
    if (validatedCount < 10) return this.initialValidationRatio;
    const trustFactor = Math.min(validatedCount / 100, 1);
    const calculatedRatio = this.initialValidationRatio * (1 - trustFactor) + this.lowestValidationRatio * trustFactor;
    return Math.max(calculatedRatio, this.lowestValidationRatio);
  }
  /**
   * Get a NDKUser object
   *
   * @param opts
   * @returns
   */
  getUser(opts) {
    const user = new NDKUser(opts);
    user.ndk = this;
    return user;
  }
  /**
   * Get a NDKUser from a NIP05
   * @param nip05 NIP-05 ID
   * @param skipCache Skip cache
   * @returns
   */
  async getUserFromNip05(nip05, skipCache = false) {
    return NDKUser.fromNip05(nip05, this, skipCache);
  }
  /**
   * Creates and starts a new subscription.
   *
   * Subscriptions automatically start unless `autoStart` is set to `false`.
   * You can control automatic closing on EOSE via `opts.closeOnEose`.
   *
   * @param filters - A single NDKFilter object or an array of filters.
   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).
   * @param handlers - Optional handlers for subscription events. Passing handlers is the preferred method of using ndk.subscribe.
   *   - `onEvent`: Called for each event received.
   *  - `onEvents`: Called once with an array of events when the subscription starts (from the cache).
   *  - `onEose`: Called when the subscription receives EOSE.
   *  For backwards compatibility, this third parameter also accepts a relaySet, the relaySet should be passed via `opts.relaySet`.
   *
   * @param _autoStart - For backwards compatibility, this can be a boolean indicating whether to start the subscription immediately.
   *  This parameter is deprecated and will be removed in a future version.
   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).
   * @returns The created NDKSubscription instance.
   *
   * @example Basic subscription
   * ```typescript
   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });
   * sub.on("event", (event) => console.log("Kind 1 event:", event.content));
   * ```
   *
   * @example Subscription with options and direct handlers
   * ```typescript
   * const sub = ndk.subscribe(
   *   { kinds: [0], authors: [pubkey] },
   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },
   *   undefined, // Use default relay set calculation
   *   {
   *     onEvents: (events) => { // Renamed parameter
   *       if (events.length > 0) {
   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);
   *       }
   *     },
   *     onEvent: (event) => { // Renamed parameter
   *       console.log("Got profile update from relay:", event.content); // Clarified source
   *     },
   *     onEose: () => console.log("Profile subscription finished.")
   *   }
   * );
   * ```
   *
   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.
   */
  subscribe(filters, opts, autoStartOrRelaySet = true, _autoStart = true) {
    let _relaySet = opts?.relaySet;
    let autoStart = _autoStart;
    if (autoStartOrRelaySet instanceof NDKRelaySet) {
      console.warn(
        "relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0"
      );
      _relaySet = autoStartOrRelaySet;
      autoStart = _autoStart;
    } else if (typeof autoStartOrRelaySet === "boolean" || typeof autoStartOrRelaySet === "object") {
      autoStart = autoStartOrRelaySet;
    }
    const subscription = new NDKSubscription(this, filters, { relaySet: _relaySet, ...opts });
    this.subManager.add(subscription);
    const pool = subscription.pool;
    if (subscription.relaySet) {
      for (const relay of subscription.relaySet.relays) {
        pool.useTemporaryRelay(relay, void 0, subscription.filters);
      }
    }
    if (this.outboxPool && subscription.hasAuthorsFilter()) {
      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);
      this.outboxTracker?.trackUsers(authors);
    }
    if (autoStart) {
      let eventsHandler;
      if (typeof autoStart === "object") {
        if (autoStart.onEvent) subscription.on("event", autoStart.onEvent);
        if (autoStart.onEose) subscription.on("eose", autoStart.onEose);
        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;
      }
      setTimeout(() => {
        const cachedEvents = subscription.start(!eventsHandler);
        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler)
          eventsHandler(cachedEvents);
      }, 0);
    }
    return subscription;
  }
  /**
   * Attempts to fetch an event from a tag, following relay hints and
   * other best practices.
   * @param tag Tag to fetch the event from
   * @param originalEvent Event where the tag came from
   * @param subOpts Subscription options to use when fetching the event
   * @param fallback Fallback options to use when the hint relay doesn't respond
   * @returns
   */
  fetchEventFromTag = fetchEventFromTag.bind(this);
  /**
   * Fetch an event from the cache synchronously.
   * @param idOrFilter event id in bech32 format or filter
   * @returns events from the cache or null if the cache is empty
   */
  fetchEventSync(idOrFilter) {
    if (!this.cacheAdapter) throw new Error("Cache adapter not set");
    let filters;
    if (typeof idOrFilter === "string") filters = [filterFromId(idOrFilter)];
    else filters = idOrFilter;
    const sub = new NDKSubscription(this, filters);
    const events = this.cacheAdapter.query(sub);
    if (events instanceof Promise) throw new Error("Cache adapter is async");
    return events.map((e) => {
      e.ndk = this;
      return e;
    });
  }
  /**
   * Fetch a single event.
   *
   * @param idOrFilter event id in bech32 format or filter
   * @param opts subscription options
   * @param relaySetOrRelay explicit relay set to use
   */
  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {
    let filters;
    let relaySet;
    if (relaySetOrRelay instanceof NDKRelay) {
      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);
    } else if (relaySetOrRelay instanceof NDKRelaySet) {
      relaySet = relaySetOrRelay;
    }
    if (!relaySetOrRelay && typeof idOrFilter === "string") {
      if (!isNip33AValue(idOrFilter)) {
        const relays = relaysFromBech32(idOrFilter, this);
        if (relays.length > 0) {
          relaySet = new NDKRelaySet(new Set(relays), this);
          relaySet = correctRelaySet(relaySet, this.pool);
        }
      }
    }
    if (typeof idOrFilter === "string") {
      filters = [filterFromId(idOrFilter)];
    } else if (Array.isArray(idOrFilter)) {
      filters = idOrFilter;
    } else {
      filters = [idOrFilter];
    }
    if (filters.length === 0) {
      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);
    }
    return new Promise((resolve) => {
      let fetchedEvent = null;
      const subscribeOpts = {
        ...opts || {},
        closeOnEose: true
      };
      if (relaySet) subscribeOpts.relaySet = relaySet;
      const s = this.subscribe(
        filters,
        subscribeOpts,
        // relaySet, // Removed: Passed via opts
        false
        // autoStart = false
      );
      const t2 = setTimeout(() => {
        s.stop();
        resolve(fetchedEvent);
      }, 1e4);
      s.on("event", (event) => {
        event.ndk = this;
        if (!event.isReplaceable()) {
          clearTimeout(t2);
          resolve(event);
        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {
          fetchedEvent = event;
        }
      });
      s.on("eose", () => {
        clearTimeout(t2);
        resolve(fetchedEvent);
      });
      s.start();
    });
  }
  /**
   * Fetch events
   */
  async fetchEvents(filters, opts, relaySet) {
    return new Promise((resolve) => {
      const events = /* @__PURE__ */ new Map();
      const subscribeOpts = {
        ...opts || {},
        closeOnEose: true
      };
      if (relaySet) subscribeOpts.relaySet = relaySet;
      const relaySetSubscription = this.subscribe(
        filters,
        subscribeOpts,
        // relaySet, // Removed: Passed via opts
        false
        // autoStart = false
      );
      const onEvent = (event) => {
        let _event;
        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);
        else _event = event;
        const dedupKey = _event.deduplicationKey();
        const existingEvent = events.get(dedupKey);
        if (existingEvent) {
          _event = dedup(existingEvent, _event);
        }
        _event.ndk = this;
        events.set(dedupKey, _event);
      };
      relaySetSubscription.on("event", onEvent);
      relaySetSubscription.on("eose", () => {
        resolve(new Set(events.values()));
      });
      relaySetSubscription.start();
    });
  }
  /**
   * Ensures that a signer is available to sign an event.
   */
  assertSigner() {
    if (!this.signer) {
      this.emit("signer:required");
      throw new Error("Signer required");
    }
  }
  getEntity = getEntity.bind(this);
  set wallet(wallet) {
    if (!wallet) {
      this.walletConfig = void 0;
      return;
    }
    this.walletConfig ??= {};
    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);
    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);
  }
};

// src/zap/invoice.ts
import { decode } from "light-bolt11-decoder";

// src/zapper/index.ts
import createDebug5 from "debug";
import { EventEmitter as EventEmitter9 } from "tseep";

// src/zapper/ln.ts
import { bech32 } from "@scure/base";
import createDebug4 from "debug";
var d2 = createDebug4("ndk:zapper:ln");

// src/zapper/nip57.ts
import { nip57 } from "nostr-tools";

// src/zapper/index.ts
var d3 = createDebug5("ndk:zapper");

// src/events/kinds/cashu/token.ts
function proofsTotalBalance(proofs) {
  return proofs.reduce((acc, proof) => {
    if (proof.amount < 0) {
      throw new Error("proof amount is negative");
    }
    return acc + proof.amount;
  }, 0);
}
var NDKCashuToken = class _NDKCashuToken extends NDKEvent {
  _proofs = [];
  _mint;
  static kind = 7375 /* CashuToken */;
  static kinds = [7375 /* CashuToken */];
  /**
   * Tokens that this token superseeds
   */
  _deletes = [];
  original;
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 7375 /* CashuToken */;
  }
  static async from(event) {
    const token = new _NDKCashuToken(event.ndk, event);
    token.original = event;
    try {
      await token.decrypt();
    } catch {
      token.content = token.original.content;
    }
    try {
      const content = JSON.parse(token.content);
      token.proofs = content.proofs;
      token.mint = content.mint ?? token.tagValue("mint");
      token.deletedTokens = content.del ?? [];
      if (!Array.isArray(token.proofs)) return;
    } catch (_e) {
      return;
    }
    return token;
  }
  get proofs() {
    return this._proofs;
  }
  set proofs(proofs) {
    const cs = /* @__PURE__ */ new Set();
    this._proofs = proofs.filter((proof) => {
      if (cs.has(proof.C)) {
        console.warn("Passed in proofs had duplicates, ignoring", proof.C);
        return false;
      }
      if (proof.amount < 0) {
        console.warn("Invalid proof with negative amount", proof);
        return false;
      }
      cs.add(proof.C);
      return true;
    }).map(this.cleanProof);
  }
  /**
   * Returns a minimal proof object with only essential properties
   */
  cleanProof(proof) {
    return {
      id: proof.id,
      amount: proof.amount,
      C: proof.C,
      secret: proof.secret
    };
  }
  async toNostrEvent(pubkey) {
    if (!this.ndk) throw new Error("no ndk");
    if (!this.ndk.signer) throw new Error("no signer");
    const payload = {
      proofs: this.proofs.map(this.cleanProof),
      mint: this.mint,
      del: this.deletedTokens ?? []
    };
    this.content = JSON.stringify(payload);
    const user = await this.ndk.signer.user();
    await this.encrypt(user, void 0, "nip44");
    return super.toNostrEvent(pubkey);
  }
  set mint(mint) {
    this._mint = mint;
  }
  get mint() {
    return this._mint;
  }
  /**
   * Tokens that were deleted by the creation of this token.
   */
  get deletedTokens() {
    return this._deletes;
  }
  /**
   * Marks tokens that were deleted by the creation of this token.
   */
  set deletedTokens(tokenIds) {
    this._deletes = tokenIds;
  }
  get amount() {
    return proofsTotalBalance(this.proofs);
  }
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    if (this.original) {
      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);
    }
    return super.publish(relaySet, timeoutMs, requiredRelayCount);
  }
};

// src/events/wrap.ts
var registeredEventClasses = /* @__PURE__ */ new Set();
function wrapEvent(event) {
  const eventWrappingMap = /* @__PURE__ */ new Map();
  const builtInClasses = [
    NDKImage,
    NDKVideo,
    NDKCashuMintList,
    NDKArticle,
    NDKHighlight,
    NDKDraft,
    NDKWiki,
    NDKNutzap,
    NDKProject,
    NDKTask,
    NDKProjectTemplate,
    NDKSimpleGroupMemberList,
    NDKSimpleGroupMetadata,
    NDKSubscriptionTier,
    NDKCashuToken,
    NDKList,
    NDKStory,
    NDKBlossomList,
    NDKFollowPack
  ];
  const allClasses = [...builtInClasses, ...registeredEventClasses];
  for (const klass2 of allClasses) {
    for (const kind of klass2.kinds) {
      eventWrappingMap.set(kind, klass2);
    }
  }
  const klass = eventWrappingMap.get(event.kind);
  if (klass) return klass.from(event);
  return event;
}

// src/subscription/index.ts
var defaultOpts = {
  closeOnEose: false,
  cacheUsage: "CACHE_FIRST" /* CACHE_FIRST */,
  dontSaveToCache: false,
  groupable: true,
  groupableDelay: 100,
  groupableDelayType: "at-most",
  cacheUnconstrainFilter: ["limit", "since", "until"]
};
var NDKSubscription = class extends EventEmitter10 {
  subId;
  filters;
  opts;
  pool;
  skipVerification = false;
  skipValidation = false;
  /**
   * Tracks the filters as they are executed on each relay
   */
  relayFilters;
  relaySet;
  ndk;
  debug;
  /**
   * Events that have been seen by the subscription, with the time they were first seen.
   */
  eventFirstSeen = /* @__PURE__ */ new Map();
  /**
   * Relays that have sent an EOSE.
   */
  eosesSeen = /* @__PURE__ */ new Set();
  /**
   * The time the last event was received by the subscription.
   * This is used to calculate when EOSE should be emitted.
   */
  lastEventReceivedAt;
  /**
   * The most recent event timestamp from cache results.
   * This is used for addSinceFromCache functionality.
   */
  mostRecentCacheEventTimestamp;
  internalId;
  /**
   * Whether the subscription should close when all relays have reached the end of the event stream.
   */
  closeOnEose;
  /**
   * Pool monitor callback
   */
  poolMonitor;
  skipOptimisticPublishEvent = false;
  /**
   * Filters to remove when querying the cache.
   */
  cacheUnconstrainFilter;
  constructor(ndk, filters, opts, subId) {
    super();
    this.ndk = ndk;
    this.opts = { ...defaultOpts, ...opts || {} };
    this.pool = this.opts.pool || ndk.pool;
    this.filters = Array.isArray(filters) ? filters : [filters];
    this.subId = subId || this.opts.subId;
    this.internalId = Math.random().toString(36).substring(7);
    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);
    if (this.opts.relaySet) {
      this.relaySet = this.opts.relaySet;
    } else if (this.opts.relayUrls) {
      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);
    }
    this.skipVerification = this.opts.skipVerification || false;
    this.skipValidation = this.opts.skipValidation || false;
    this.closeOnEose = this.opts.closeOnEose || false;
    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;
    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;
  }
  /**
   * Returns the relays that have not yet sent an EOSE.
   */
  relaysMissingEose() {
    if (!this.relayFilters) return [];
    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(
      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))
    );
    return relaysMissingEose;
  }
  /**
   * Provides access to the first filter of the subscription for
   * backwards compatibility.
   */
  get filter() {
    return this.filters[0];
  }
  get groupableDelay() {
    if (!this.isGroupable()) return void 0;
    return this.opts?.groupableDelay;
  }
  get groupableDelayType() {
    return this.opts?.groupableDelayType || "at-most";
  }
  isGroupable() {
    return this.opts?.groupable || false;
  }
  shouldQueryCache() {
    if (this.opts.addSinceFromCache) return true;
    if (this.opts?.cacheUsage === "ONLY_RELAY" /* ONLY_RELAY */) return false;
    const hasNonEphemeralKind = this.filters.some(
      (f) => f.kinds?.some((k) => kindIsEphemeral(k))
    );
    if (hasNonEphemeralKind) return true;
    return true;
  }
  shouldQueryRelays() {
    return this.opts?.cacheUsage !== "ONLY_CACHE" /* ONLY_CACHE */;
  }
  shouldWaitForCache() {
    if (this.opts.addSinceFromCache) return true;
    return (
      // Must want to close on EOSE; subscriptions
      // that want to receive further updates must
      // always hit the relay
      !!this.opts.closeOnEose && // Cache adapter must claim to be fast
      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then
      // we should not wait for the cache
      this.opts.cacheUsage !== "PARALLEL" /* PARALLEL */
    );
  }
  /**
   * Start the subscription. This is the main method that should be called
   * after creating a subscription.
   *
   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache
   *
   * When using a synchronous cache, the events will be returned immediately
   * by this function. If you will use those returned events, you should
   * set emitCachedEvents to false to prevent seeing them as duplicate events.
   */
  start(emitCachedEvents = true) {
    let cacheResult;
    const updateStateFromCacheResults = (events) => {
      if (emitCachedEvents) {
        for (const event of events) {
          if (event.created_at && (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp)) {
            this.mostRecentCacheEventTimestamp = event.created_at;
          }
          this.eventReceived(event, void 0, true, false);
        }
      } else {
        cacheResult = [];
        for (const event of events) {
          if (event.created_at && (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp)) {
            this.mostRecentCacheEventTimestamp = event.created_at;
          }
          event.ndk = this.ndk;
          const e = this.opts.wrap ? wrapEvent(event) : event;
          if (!e) break;
          if (e instanceof Promise) {
            e.then((wrappedEvent) => {
              this.emitEvent(false, wrappedEvent, void 0, true, false);
            });
            break;
          }
          this.eventFirstSeen.set(e.id, Date.now());
          cacheResult.push(e);
        }
      }
    };
    const loadFromRelays = () => {
      if (this.shouldQueryRelays()) {
        this.startWithRelays();
        this.startPoolMonitor();
      } else {
        this.emit("eose", this);
      }
    };
    if (this.shouldQueryCache()) {
      cacheResult = this.startWithCache();
      if (cacheResult instanceof Promise) {
        if (this.shouldWaitForCache()) {
          cacheResult.then((events) => {
            updateStateFromCacheResults(events);
            if (queryFullyFilled(this)) {
              this.emit("eose", this);
              return;
            }
            loadFromRelays();
          });
          return null;
        }
        cacheResult.then((events) => {
          updateStateFromCacheResults(events);
        });
        loadFromRelays();
        return null;
      }
      updateStateFromCacheResults(cacheResult);
      if (queryFullyFilled(this)) {
        this.emit("eose", this);
      } else {
        loadFromRelays();
      }
      return cacheResult;
    }
    loadFromRelays();
    return null;
  }
  /**
   * We want to monitor for new relays that are coming online, in case
   * they should be part of this subscription.
   */
  startPoolMonitor() {
    const _d = this.debug.extend("pool-monitor");
    this.poolMonitor = (relay) => {
      if (this.relayFilters?.has(relay.url)) return;
      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);
      if (calc.get(relay.url)) {
        this.relayFilters?.set(relay.url, this.filters);
        relay.subscribe(this, this.filters);
      }
    };
    this.pool.on("relay:connect", this.poolMonitor);
  }
  onStopped;
  stop() {
    this.emit("close", this);
    this.poolMonitor && this.pool.off("relay:connect", this.poolMonitor);
    this.onStopped?.();
  }
  /**
   * @returns Whether the subscription has an authors filter.
   */
  hasAuthorsFilter() {
    return this.filters.some((f) => f.authors?.length);
  }
  startWithCache() {
    if (this.ndk.cacheAdapter?.query) {
      return this.ndk.cacheAdapter.query(this);
    }
    return [];
  }
  /**
   * Find available relays that should be part of this subscription and execute in them.
   *
   * Note that this is executed in addition to using the pool monitor, so even if the relay set
   * that is computed (i.e. we don't have any relays available), when relays come online, we will
   * check if we need to execute in them.
   */
  startWithRelays() {
    let filters = this.filters;
    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {
      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;
      filters = filters.map((filter) => ({
        ...filter,
        since: Math.max(filter.since || 0, sinceTimestamp)
      }));
    }
    if (!this.relaySet || this.relaySet.relays.size === 0) {
      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);
    } else {
      this.relayFilters = /* @__PURE__ */ new Map();
      for (const relay of this.relaySet.relays) {
        this.relayFilters.set(relay.url, filters);
      }
    }
    for (const [relayUrl, filters2] of this.relayFilters) {
      const relay = this.pool.getRelay(relayUrl, true, true, filters2);
      relay.subscribe(this, filters2);
    }
  }
  // EVENT handling
  /**
   * Called when an event is received from a relay or the cache
   * @param event
   * @param relay
   * @param fromCache Whether the event was received from the cache
   * @param optimisticPublish Whether this event is coming from an optimistic publish
   */
  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {
    const eventId = event.id;
    const eventAlreadySeen = this.eventFirstSeen.has(eventId);
    let ndkEvent;
    if (event instanceof NDKEvent) ndkEvent = event;
    if (!eventAlreadySeen) {
      ndkEvent ??= new NDKEvent(this.ndk, event);
      ndkEvent.ndk = this.ndk;
      ndkEvent.relay = relay;
      if (!fromCache && !optimisticPublish) {
        if (!this.skipValidation) {
          if (!ndkEvent.isValid) {
            this.debug("Event failed validation %s from relay %s", eventId, relay?.url);
            return;
          }
        }
        if (relay) {
          const shouldVerify = relay.shouldValidateEvent();
          if (shouldVerify && !this.skipVerification) {
            ndkEvent.relay = relay;
            if (!this.ndk.asyncSigVerification) {
              if (!ndkEvent.verifySignature(true)) {
                this.debug("Event failed signature validation", event);
                this.ndk.reportInvalidSignature(ndkEvent, relay);
                return;
              }
              relay.addValidatedEvent();
            }
          } else {
            relay.addNonValidatedEvent();
          }
        }
        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {
          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);
        }
      }
      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {
        this.emitEvent(
          this.opts?.wrap ?? false,
          ndkEvent,
          relay,
          fromCache,
          optimisticPublish
        );
        this.eventFirstSeen.set(eventId, Date.now());
      }
    } else {
      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);
      this.emit(
        "event:dup",
        event,
        relay,
        timeSinceFirstSeen,
        this,
        fromCache,
        optimisticPublish
      );
      if (relay) {
        const signature = verifiedSignatures.get(eventId);
        if (signature && typeof signature === "string") {
          if (event.sig === signature) {
            relay.addValidatedEvent();
          } else {
            const eventToReport = event instanceof NDKEvent ? event : new NDKEvent(this.ndk, event);
            this.ndk.reportInvalidSignature(eventToReport, relay);
          }
        }
      }
    }
    this.lastEventReceivedAt = Date.now();
  }
  /**
   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)
   */
  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {
    const wrapped = wrap ? wrapEvent(evt) : evt;
    if (wrapped instanceof Promise) {
      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));
    } else if (wrapped) {
      this.emit(
        "event",
        wrapped,
        relay,
        this,
        fromCache,
        optimisticPublish
      );
    }
  }
  closedReceived(relay, reason) {
    this.emit("closed", relay, reason);
  }
  // EOSE handling
  eoseTimeout;
  eosed = false;
  eoseReceived(relay) {
    this.debug("EOSE received from %s", relay.url);
    this.eosesSeen.add(relay);
    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;
    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;
    const queryFilled = queryFullyFilled(this);
    const performEose = (reason) => {
      this.debug("Performing EOSE: %s %d", reason, this.eosed);
      if (this.eosed) return;
      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);
      this.emit("eose", this);
      this.eosed = true;
      if (this.opts?.closeOnEose) this.stop();
    };
    if (queryFilled || hasSeenAllEoses) {
      performEose("query filled or seen all");
    } else if (this.relayFilters) {
      let timeToWaitForNextEose = 1e3;
      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));
      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(
        (url) => connectedRelays.has(url)
      );
      if (connectedRelaysWithFilters.length === 0) {
        this.debug(
          "No connected relays, waiting for all relays to connect",
          Array.from(this.relayFilters.keys()).join(", ")
        );
        return;
      }
      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;
      this.debug("Percentage of relays that have sent EOSE", {
        subId: this.subId,
        percentageOfRelaysThatHaveSentEose,
        seen: this.eosesSeen.size,
        total: connectedRelaysWithFilters.length
      });
      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {
        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);
        if (timeToWaitForNextEose === 0) {
          performEose("time to wait was 0");
          return;
        }
        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);
        const sendEoseTimeout = () => {
          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;
          if (lastEventSeen !== void 0 && lastEventSeen < 20) {
            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);
          } else {
            performEose(`send eose timeout: ${timeToWaitForNextEose}`);
          }
        };
        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);
      }
    }
  }
};
var kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;

// src/user/follows.ts
async function follows(opts, outbox, kind = 3 /* Contacts */) {
  if (!this.ndk) throw new Error("NDK not set");
  const contactListEvent = await this.ndk.fetchEvent(
    { kinds: [kind], authors: [this.pubkey] },
    opts || { groupable: false }
  );
  if (contactListEvent) {
    const pubkeys = /* @__PURE__ */ new Set();
    contactListEvent.tags.forEach((tag) => {
      if (tag[0] === "p") pubkeys.add(tag[1]);
    });
    if (outbox) {
      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));
    }
    return [...pubkeys].reduce((acc, pubkey) => {
      const user = new NDKUser({ pubkey });
      user.ndk = this.ndk;
      acc.add(user);
      return acc;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}

// src/user/nip05.ts
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/;
async function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {
  return await ndk.queuesNip05.add({
    id: fullname,
    func: async () => {
      if (ndk.cacheAdapter?.loadNip05) {
        const profile = await ndk.cacheAdapter.loadNip05(fullname);
        if (profile !== "missing") {
          if (profile) {
            const user = new NDKUser({
              pubkey: profile.pubkey,
              relayUrls: profile.relays,
              nip46Urls: profile.nip46
            });
            user.ndk = ndk;
            return user;
          }
          if (fetchOpts.cache !== "no-cache") {
            return null;
          }
        }
      }
      const match = fullname.match(NIP05_REGEX);
      if (!match) return null;
      const [_, name = "_", domain] = match;
      try {
        const res = await _fetch(
          `https://${domain}/.well-known/nostr.json?name=${name}`,
          fetchOpts
        );
        const { names, relays, nip46 } = parseNIP05Result(await res.json());
        const pubkey = names[name.toLowerCase()];
        let profile = null;
        if (pubkey) {
          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };
        }
        if (ndk?.cacheAdapter?.saveNip05) {
          ndk.cacheAdapter.saveNip05(fullname, profile);
        }
        return profile;
      } catch (_e) {
        if (ndk?.cacheAdapter?.saveNip05) {
          ndk?.cacheAdapter.saveNip05(fullname, null);
        }
        console.error("Failed to fetch NIP05 for", fullname, _e);
        return null;
      }
    }
  });
}
function parseNIP05Result(json) {
  const result = {
    names: {}
  };
  for (const [name, pubkey] of Object.entries(json.names)) {
    if (typeof name === "string" && typeof pubkey === "string") {
      result.names[name.toLowerCase()] = pubkey;
    }
  }
  if (json.relays) {
    result.relays = {};
    for (const [pubkey, relays] of Object.entries(json.relays)) {
      if (typeof pubkey === "string" && Array.isArray(relays)) {
        result.relays[pubkey] = relays.filter(
          (relay) => typeof relay === "string"
        );
      }
    }
  }
  if (json.nip46) {
    result.nip46 = {};
    for (const [pubkey, nip46] of Object.entries(json.nip46)) {
      if (typeof pubkey === "string" && Array.isArray(nip46)) {
        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === "string");
      }
    }
  }
  return result;
}

// src/user/index.ts
var NDKUser = class _NDKUser {
  ndk;
  profile;
  profileEvent;
  _npub;
  _pubkey;
  relayUrls = [];
  nip46Urls = [];
  constructor(opts) {
    if (opts.npub) this._npub = opts.npub;
    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;
    if (opts.pubkey) this._pubkey = opts.pubkey;
    if (opts.relayUrls) this.relayUrls = opts.relayUrls;
    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;
    if (opts.nprofile) {
      try {
        const decoded = nip196.decode(opts.nprofile);
        if (decoded.type === "nprofile") {
          this._pubkey = decoded.data.pubkey;
          if (decoded.data.relays && decoded.data.relays.length > 0) {
            this.relayUrls.push(...decoded.data.relays);
          }
        }
      } catch (e) {
        console.error("Failed to decode nprofile", e);
      }
    }
  }
  get npub() {
    if (!this._npub) {
      if (!this._pubkey) throw new Error("pubkey not set");
      this._npub = nip196.npubEncode(this.pubkey);
    }
    return this._npub;
  }
  get nprofile() {
    const relays = this.profileEvent?.onRelays?.map((r) => r.url);
    return nip196.nprofileEncode({
      pubkey: this.pubkey,
      relays
    });
  }
  set npub(npub2) {
    this._npub = npub2;
  }
  /**
   * Get the user's pubkey
   * @returns {string} The user's pubkey
   */
  get pubkey() {
    if (!this._pubkey) {
      if (!this._npub) throw new Error("npub not set");
      this._pubkey = nip196.decode(this.npub).data;
    }
    return this._pubkey;
  }
  /**
   * Set the user's pubkey
   * @param pubkey {string} The user's pubkey
   */
  set pubkey(pubkey) {
    this._pubkey = pubkey;
  }
  /**
   * Equivalent to NDKEvent.filters().
   * @returns {NDKFilter}
   */
  filter() {
    return { "#p": [this.pubkey] };
  }
  /**
   * Gets NIP-57 and NIP-61 information that this user has signaled
   *
   * @param getAll {boolean} Whether to get all zap info or just the first one
   */
  async getZapInfo(timeoutMs) {
    if (!this.ndk) throw new Error("No NDK instance found");
    const promiseWithTimeout = async (promise) => {
      if (!timeoutMs) return promise;
      let timeoutId;
      const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => reject(new Error("Timeout")), timeoutMs);
      });
      try {
        const result = await Promise.race([promise, timeoutPromise]);
        if (timeoutId) clearTimeout(timeoutId);
        return result;
      } catch (e) {
        if (e instanceof Error && e.message === "Timeout") {
          try {
            const result = await promise;
            return result;
          } catch (_originalError) {
            return void 0;
          }
        }
        return void 0;
      }
    };
    const [userProfile, mintListEvent] = await Promise.all([
      promiseWithTimeout(this.fetchProfile()),
      promiseWithTimeout(
        this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] })
      )
    ]);
    const res = /* @__PURE__ */ new Map();
    if (mintListEvent) {
      const mintList = NDKCashuMintList.from(mintListEvent);
      if (mintList.mints.length > 0) {
        res.set("nip61", {
          mints: mintList.mints,
          relays: mintList.relays,
          p2pk: mintList.p2pk
        });
      }
    }
    if (userProfile) {
      const { lud06, lud16 } = userProfile;
      res.set("nip57", { lud06, lud16 });
    }
    return res;
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @param ndk {NDK} An NDK instance
   * @param skipCache {boolean} Whether to skip the cache or not
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(nip05Id, ndk, skipCache = false) {
    if (!ndk) throw new Error("No NDK instance found");
    const opts = {};
    if (skipCache) opts.cache = "no-cache";
    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);
    if (profile) {
      const user = new _NDKUser({
        pubkey: profile.pubkey,
        relayUrls: profile.relays,
        nip46Urls: profile.nip46
      });
      user.ndk = ndk;
      return user;
    }
  }
  /**
   * Fetch a user's profile
   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
   * @param storeProfileEvent {boolean} Whether to store the profile event or not
   * @returns User Profile
   */
  async fetchProfile(opts, storeProfileEvent = false) {
    if (!this.ndk) throw new Error("NDK not set");
    let setMetadataEvent = null;
    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== "ONLY_RELAY" /* ONLY_RELAY */) {
      let profile = null;
      if (this.ndk.cacheAdapter.fetchProfileSync) {
        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);
      } else if (this.ndk.cacheAdapter.fetchProfile) {
        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);
      }
      if (profile) {
        this.profile = profile;
        return profile;
      }
    }
    opts ??= {};
    opts.cacheUsage ??= "ONLY_RELAY" /* ONLY_RELAY */;
    opts.closeOnEose ??= true;
    opts.groupable ??= true;
    opts.groupableDelay ??= 250;
    if (!setMetadataEvent) {
      setMetadataEvent = await this.ndk.fetchEvent(
        { kinds: [0], authors: [this.pubkey] },
        opts
      );
    }
    if (!setMetadataEvent) return null;
    this.profile = profileFromEvent(setMetadataEvent);
    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {
      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);
    }
    return this.profile;
  }
  /**
   * Returns a set of users that this user follows.
   *
   * @deprecated Use followSet instead
   */
  follows = follows.bind(this);
  /**
   * Returns a set of pubkeys that this user follows.
   *
   * @param opts - NDKSubscriptionOptions
   * @param outbox - boolean
   * @param kind - number
   */
  async followSet(opts, outbox, kind = 3 /* Contacts */) {
    const follows2 = await this.follows(opts, outbox, kind);
    return new Set(Array.from(follows2).map((f) => f.pubkey));
  }
  /** @deprecated Use referenceTags instead. */
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.pubkey];
  }
  /**
   * Get the tags that can be used to reference this user in an event
   * @returns {NDKTag[]} an array of NDKTag
   */
  referenceTags(marker) {
    const tag = [["p", this.pubkey]];
    if (!marker) return tag;
    tag[0].push("", marker);
    return tag;
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk) throw new Error("No NDK instance found");
    if (!this.profile) throw new Error("No profile available");
    this.ndk.assertSigner();
    const event = new NDKEvent(this.ndk, {
      kind: 0,
      content: serializeProfile(this.profile)
    });
    await event.publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    if (!currentFollowList) {
      currentFollowList = await this.follows(void 0, void 0, kind);
    }
    if (currentFollowList.has(newFollow)) {
      return false;
    }
    currentFollowList.add(newFollow);
    const event = new NDKEvent(this.ndk, { kind });
    for (const follow of currentFollowList) {
      event.tag(follow);
    }
    await event.publish();
    return true;
  }
  /**
   * Remove a follow from this user's contact list
   *
   * @param user {NDKUser} The user to unfollow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns The relays were the follow list was published or false if the user wasn't found
   */
  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    if (!currentFollowList) {
      currentFollowList = await this.follows(void 0, void 0, kind);
    }
    const newUserFollowList = /* @__PURE__ */ new Set();
    let foundUser = false;
    for (const follow of currentFollowList) {
      if (follow.pubkey !== user.pubkey) {
        newUserFollowList.add(follow);
      } else {
        foundUser = true;
      }
    }
    if (!foundUser) return false;
    const event = new NDKEvent(this.ndk, { kind });
    for (const follow of newUserFollowList) {
      event.tag(follow);
    }
    return await event.publish();
  }
  /**
   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
   *
   * @param nip05Id The NIP-05 string to validate
   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
   * False if the NIP-05 is found but doesn't match this user's pubkey,
   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
   */
  async validateNip05(nip05Id) {
    if (!this.ndk) throw new Error("No NDK instance found");
    const profilePointer = await getNip05For(this.ndk, nip05Id);
    if (profilePointer === null) return null;
    return profilePointer.pubkey === this.pubkey;
  }
};

// src/signers/private-key/index.ts
var NDKPrivateKeySigner = class _NDKPrivateKeySigner {
  _user;
  _privateKey;
  _pubkey;
  /**
   * Create a new signer from a private key.
   * @param privateKey - The private key to use in hex form or nsec.
   * @param ndk - The NDK instance to use.
   */
  constructor(privateKeyOrNsec, ndk) {
    if (typeof privateKeyOrNsec === "string") {
      if (privateKeyOrNsec.startsWith("nsec1")) {
        const { type, data } = nip197.decode(privateKeyOrNsec);
        if (type === "nsec") this._privateKey = data;
        else throw new Error("Invalid private key provided.");
      } else if (privateKeyOrNsec.length === 64) {
        this._privateKey = hexToBytes2(privateKeyOrNsec);
      } else {
        throw new Error("Invalid private key provided.");
      }
    } else {
      this._privateKey = privateKeyOrNsec;
    }
    this._pubkey = getPublicKey(this._privateKey);
    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });
    this._user ??= new NDKUser({ pubkey: this._pubkey });
  }
  /**
   * Get the private key in hex form.
   */
  get privateKey() {
    if (!this._privateKey) throw new Error("Not ready");
    return bytesToHex2(this._privateKey);
  }
  /**
   * Get the public key in hex form.
   */
  get pubkey() {
    if (!this._pubkey) throw new Error("Not ready");
    return this._pubkey;
  }
  /**
   * Get the private key in nsec form.
   */
  get nsec() {
    if (!this._privateKey) throw new Error("Not ready");
    return nip197.nsecEncode(this._privateKey);
  }
  /**
   * Get the public key in npub form.
   */
  get npub() {
    if (!this._pubkey) throw new Error("Not ready");
    return nip197.npubEncode(this._pubkey);
  }
  /**
   * Generate a new private key.
   */
  static generate() {
    const privateKey = generateSecretKey();
    return new _NDKPrivateKeySigner(privateKey);
  }
  /**
   * Noop in NDKPrivateKeySigner.
   */
  async blockUntilReady() {
    return this._user;
  }
  /**
   * Get the user.
   */
  async user() {
    return this._user;
  }
  /**
   * Get the user.
   */
  get userSync() {
    return this._user;
  }
  async sign(event) {
    if (!this._privateKey) {
      throw Error("Attempted to sign without a private key");
    }
    return finalizeEvent(event, this._privateKey).sig;
  }
  async encryptionEnabled(scheme) {
    const enabled = [];
    if (!scheme || scheme === "nip04") enabled.push("nip04");
    if (!scheme || scheme === "nip44") enabled.push("nip44");
    return enabled;
  }
  async encrypt(recipient, value, scheme) {
    if (!this._privateKey || !this.privateKey) {
      throw Error("Attempted to encrypt without a private key");
    }
    const recipientHexPubKey = recipient.pubkey;
    if (scheme === "nip44") {
      const conversationKey = nip44.v2.utils.getConversationKey(
        this._privateKey,
        recipientHexPubKey
      );
      return await nip44.v2.encrypt(value, conversationKey);
    }
    return await nip04.encrypt(this._privateKey, recipientHexPubKey, value);
  }
  async decrypt(sender, value, scheme) {
    if (!this._privateKey || !this.privateKey) {
      throw Error("Attempted to decrypt without a private key");
    }
    const senderHexPubKey = sender.pubkey;
    if (scheme === "nip44") {
      const conversationKey = nip44.v2.utils.getConversationKey(
        this._privateKey,
        senderHexPubKey
      );
      return await nip44.v2.decrypt(value, conversationKey);
    }
    return await nip04.decrypt(this._privateKey, senderHexPubKey, value);
  }
  /**
   * Serializes the signer's private key into a storable format.
   * @returns A JSON string containing the type and the hex private key.
   */
  toPayload() {
    if (!this._privateKey) throw new Error("Private key not available");
    const payload = {
      type: "private-key",
      payload: this.privateKey
      // Use the hex private key
    };
    return JSON.stringify(payload);
  }
  /**
   * Deserializes the signer from a payload string.
   * @param payloadString The JSON string obtained from toPayload().
   * @param ndk Optional NDK instance.
   * @returns An instance of NDKPrivateKeySigner.
   */
  static async fromPayload(payloadString, ndk) {
    const payload = JSON.parse(payloadString);
    if (payload.type !== "private-key") {
      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);
    }
    if (!payload.payload || typeof payload.payload !== "string") {
      throw new Error("Invalid payload content for private-key signer");
    }
    return new _NDKPrivateKeySigner(payload.payload, ndk);
  }
};
registerSigner("private-key", NDKPrivateKeySigner);

// test/mocks/event-generator.ts
var EventGenerator = class _EventGenerator {
  static privateKeys = /* @__PURE__ */ new Map();
  static ndk = null;
  static setNDK(ndk) {
    _EventGenerator.ndk = ndk;
    if (!ndk.signer) {
      ndk.signer = NDKPrivateKeySigner.generate();
    }
  }
  static getPrivateKeyForPubkey(pubkey) {
    if (!_EventGenerator.privateKeys.has(pubkey)) {
      const signer = NDKPrivateKeySigner.generate();
      const hexPrivateKey = signer.privateKey;
      const generatedPubkey = signer.pubkey;
      if (!pubkey || pubkey === generatedPubkey) {
        _EventGenerator.privateKeys.set(generatedPubkey, hexPrivateKey);
        return hexPrivateKey;
      }
      _EventGenerator.privateKeys.set(pubkey, hexPrivateKey);
    }
    return _EventGenerator.privateKeys.get(pubkey) || "";
  }
  static createEvent(kind = 1, content = "", pubkey = "") {
    if (!_EventGenerator.ndk) {
      throw new Error("NDK not set in EventGenerator. Call setNDK first.");
    }
    if (!pubkey) {
      const signer = NDKPrivateKeySigner.generate();
      pubkey = signer.pubkey;
    }
    const event = new NDKEvent(_EventGenerator.ndk);
    event.kind = kind;
    event.pubkey = pubkey;
    event.content = content;
    return event;
  }
  static async createSignedTextNote(content, pubkey = "") {
    if (!_EventGenerator.ndk) {
      throw new Error("NDK not set in EventGenerator. Call setNDK first.");
    }
    if (!pubkey) {
      const signer = NDKPrivateKeySigner.generate();
      pubkey = signer.pubkey;
    }
    const _privateKey = _EventGenerator.getPrivateKeyForPubkey(pubkey);
    const event = _EventGenerator.createEvent(1, content, pubkey);
    await event.sign();
    return event;
  }
  static async createEncryptedDirectMessage(content, from, to) {
    if (!_EventGenerator.ndk) {
      throw new Error("NDK not set in EventGenerator. Call setNDK first.");
    }
    const event = _EventGenerator.createEvent(4, content, from);
    event.tags.push(["p", to]);
    await event.sign();
    return event;
  }
  static async createRepost(originalEvent, pubkey = "") {
    if (!_EventGenerator.ndk) {
      throw new Error("NDK not set in EventGenerator. Call setNDK first.");
    }
    if (!pubkey) {
      const signer = NDKPrivateKeySigner.generate();
      pubkey = signer.pubkey;
    }
    const event = _EventGenerator.createEvent(
      6,
      // Repost kind
      JSON.stringify(await originalEvent.toNostrEvent()),
      pubkey
    );
    event.tags.push(["e", originalEvent.id || ""]);
    event.tags.push(["p", originalEvent.pubkey]);
    await event.sign();
    return event;
  }
  static async createParameterizedReplaceable(kind, content, pubkey = "", dTag = "") {
    if (!_EventGenerator.ndk) {
      throw new Error("NDK not set in EventGenerator. Call setNDK first.");
    }
    if (kind < 3e4 || kind > 39999) {
      throw new Error(
        `Invalid parameterized replaceable event kind: ${kind}. Must be between 30000-39999.`
      );
    }
    if (!pubkey) {
      const signer = NDKPrivateKeySigner.generate();
      pubkey = signer.pubkey;
    }
    const event = _EventGenerator.createEvent(kind, content, pubkey);
    event.tags.push(["d", dTag]);
    await event.sign();
    return event;
  }
};

// test/mocks/nutzaps.ts
async function mockNutzap(mint, amount, ndk, {
  senderPk = NDKPrivateKeySigner.generate(),
  recipientPubkey,
  content = ""
} = {}) {
  if (!recipientPubkey) {
    ndk.assertSigner();
    recipientPubkey = (await ndk.signer?.user()).pubkey;
  }
  const nutzap = new NDKNutzap(ndk);
  nutzap.mint = mint;
  nutzap.proofs = [mockProof(mint, amount, recipientPubkey)];
  if (recipientPubkey) {
    nutzap.recipientPubkey = recipientPubkey;
  }
  nutzap.comment = content;
  await nutzap.sign(senderPk);
  return nutzap;
}
function mockProof(C, amount, p2pk) {
  const proof = {
    C,
    amount,
    id: "mint",
    secret: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
  };
  if (p2pk) {
    proof.secret = JSON.stringify([
      "P2PK",
      {
        nonce: "4eb3d1430af5e2663634af4ff80a394cfe1d377d41ab34d6d92e03cb3f2cdc8c",
        data: `02${p2pk}`
      }
    ]);
  }
  return proof;
}

// test/helpers/test-fixtures.ts
var UserGenerator = class _UserGenerator {
  static privateKeys = {
    alice: "1f4ca0aba830226f3780bcba8dd646a5149a2be50267cb87dcdd973669977d81",
    bob: "c025cd26f6e11481566dd2459a6efa2d31976e285d04b797660eed82f0fd091f",
    carol: "5955f65c522f8ce30ed2f5863e0a0638dba945f3d2c3f372b7906e33b4cb1b83",
    dave: "2f820ff78ce23247dc58ac44492cf5c5f7554bc2753284aa62c7caea1db77cf6",
    eve: "c18cda5e6451783736a36cf2875f5e954617e44db03cb84bda43040c995dc585"
  };
  /**
   * Get a user with a deterministic private key
   * @param name The name of the user (alice, bob, carol, dave, eve)
   * @param ndk The NDK instance to use for the user
   * @returns The NDK user
   */
  static async getUser(name, ndk) {
    const privateKey = _UserGenerator.privateKeys[name.toLowerCase()];
    if (!privateKey) {
      throw new Error(`Unknown test user: ${name}`);
    }
    const signer = new NDKPrivateKeySigner(privateKey);
    await signer.blockUntilReady();
    const user = new NDKUser({ hexpubkey: signer.pubkey });
    if (ndk) {
      user.ndk = ndk;
    }
    return user;
  }
  /**
   * Get the private key for a specific test user
   * @param name The name of the user (alice, bob, carol, dave, eve)
   * @returns The private key hex string
   */
  static getPrivateKey(name) {
    const privateKey = _UserGenerator.privateKeys[name.toLowerCase()];
    if (!privateKey) {
      throw new Error(`Unknown test user: ${name}`);
    }
    return privateKey;
  }
  /**
   * Get a user with a random private key
   * @param ndk The NDK instance to use for the user
   * @returns The NDK user
   */
  static async getRandomUser(ndk) {
    const signer = NDKPrivateKeySigner.generate();
    await signer.blockUntilReady();
    const user = new NDKUser({ hexpubkey: signer.pubkey });
    if (ndk) {
      user.ndk = ndk;
    }
    return user;
  }
};
var SignerGenerator = class _SignerGenerator {
  /**
   * Get a signer for a specific test user
   * @param name The name of the user (alice, bob, carol, dave, eve)
   * @returns The NDK signer
   */
  static getSigner(name) {
    const privateKey = UserGenerator.getPrivateKey(name);
    if (!privateKey) {
      throw new Error(`Unknown test user: ${name}`);
    }
    return new NDKPrivateKeySigner(privateKey);
  }
  static async sign(event, user) {
    const signer = _SignerGenerator.getSigner(user);
    await event.sign(signer);
    return event;
  }
  /**
   * Generate a random signer
   * @returns The NDK signer
   */
  static getRandomSigner() {
    return NDKPrivateKeySigner.generate();
  }
};
var TestEventFactory = class {
  ndk;
  constructor(ndk) {
    this.ndk = ndk;
    EventGenerator.setNDK(ndk);
  }
  /**
   * Create a signed text note from a specific user
   * @param content The content of the note
   * @param user The user that authored the note, or name of predefined test user
   * @param kind The kind of the event (defaults to 1)
   * @returns The signed event
   */
  async createSignedTextNote(content, user, kind = 1) {
    let pubkey;
    let signer;
    if (typeof user === "string") {
      signer = SignerGenerator.getSigner(user);
      await signer.blockUntilReady();
      pubkey = signer.pubkey;
    } else {
      signer = NDKPrivateKeySigner.generate();
      pubkey = signer.pubkey;
    }
    const event = EventGenerator.createEvent(kind, content, pubkey);
    if (typeof user === "string") {
      this.ndk.signer = signer;
      await event.sign();
    }
    return event;
  }
  /**
   * Create a direct message from one user to another
   * @param content The content of the message
   * @param fromUser The sender (author)
   * @param toUser The recipient
   * @returns The created event (not necessarily signed)
   */
  async createDirectMessage(content, fromUser, toUser) {
    let fromPubkey;
    let toPubkey;
    if (typeof fromUser === "string") {
      const user = await UserGenerator.getUser(fromUser, this.ndk);
      fromPubkey = user.pubkey;
    } else {
      fromPubkey = fromUser.pubkey;
    }
    if (typeof toUser === "string") {
      const user = await UserGenerator.getUser(toUser, this.ndk);
      toPubkey = user.pubkey;
    } else {
      toPubkey = toUser.pubkey;
    }
    const event = EventGenerator.createEvent(4, content, fromPubkey);
    event.tags.push(["p", toPubkey]);
    if (typeof fromUser === "string") {
      const signer = SignerGenerator.getSigner(fromUser);
      this.ndk.signer = signer;
      await event.sign();
    }
    return event;
  }
  /**
   * Create a reply to an event
   * @param originalEvent The event being replied to
   * @param content The content of the reply
   * @param fromUser The author of the reply
   * @param kind The kind of the reply (defaults to same as original for kind 1, or 1111 for other kinds)
   * @returns The created reply event (not necessarily signed)
   */
  async createReply(originalEvent, content, fromUser, kind) {
    let fromPubkey;
    if (typeof fromUser === "string") {
      const user = await UserGenerator.getUser(fromUser, this.ndk);
      fromPubkey = user.pubkey;
    } else {
      fromPubkey = fromUser.pubkey;
    }
    const replyKind = kind || (originalEvent.kind === 1 ? 1 : 1111);
    const replyEvent = EventGenerator.createEvent(replyKind, content, fromPubkey);
    if (originalEvent.kind === 1) {
      replyEvent.tags.push(["e", originalEvent.id, "", "root", originalEvent.pubkey]);
      replyEvent.tags.push(["p", originalEvent.pubkey]);
    } else {
      replyEvent.tags.push([
        "A",
        `${originalEvent.kind}:${originalEvent.pubkey}:${originalEvent.getTagValue("d") || ""}`,
        ""
      ]);
      replyEvent.tags.push([
        "a",
        `${originalEvent.kind}:${originalEvent.pubkey}:${originalEvent.getTagValue("d") || ""}`,
        ""
      ]);
      replyEvent.tags.push(["P", originalEvent.pubkey]);
      replyEvent.tags.push(["K", originalEvent.kind.toString()]);
    }
    if (typeof fromUser === "string") {
      const signer = SignerGenerator.getSigner(fromUser);
      this.ndk.signer = signer;
      await replyEvent.sign();
    }
    return replyEvent;
  }
  /**
   * Creates a chain of events (e.g., a thread)
   * @param initialContent Content of the first message
   * @param replies Array of {content, author} objects for each reply
   * @returns Array of events in the chain
   */
  async createEventChain(initialContent, initialAuthor, replies) {
    const rootEvent = await this.createSignedTextNote(initialContent, initialAuthor);
    const chain = [rootEvent];
    let parentEvent = rootEvent;
    for (const reply of replies) {
      const replyEvent = await this.createReply(parentEvent, reply.content, reply.author);
      chain.push(replyEvent);
      parentEvent = replyEvent;
    }
    return chain;
  }
};
var TestFixture = class {
  ndk;
  eventFactory;
  constructor() {
    this.ndk = new NDK();
    this.eventFactory = new TestEventFactory(this.ndk);
  }
  /**
   * Get a predefined test user
   * @param name The name of the user (alice, bob, carol, dave, eve)
   * @returns The NDK user
   */
  async getUser(name) {
    return UserGenerator.getUser(name, this.ndk);
  }
  /**
   * Get a signer for a predefined test user
   * @param name The name of the user
   * @returns The NDK signer
   */
  getSigner(name) {
    const signer = SignerGenerator.getSigner(name);
    return signer;
  }
  /**
   * Set up the NDK instance with a specific signer
   * @param name The name of the predefined user to use as signer
   */
  setupSigner(name) {
    this.ndk.signer = this.getSigner(name);
  }
};

// test/helpers/time.ts
var TimeController = class _TimeController {
  static viObject;
  /**
   * Set the Vitest object to use for time control
   */
  static setViObject(vi) {
    _TimeController.viObject = vi;
  }
  /**
   * Advance timers by a specified number of milliseconds
   */
  static advanceTime(ms) {
    _TimeController.viObject?.advanceTimersByTime(ms);
  }
  /**
   * Advance timers asynchronously by a specified number of milliseconds
   */
  static async tickAsync(ms = 0) {
    await _TimeController.viObject?.advanceTimersByTimeAsync(ms);
  }
  /**
   * Clear all timers
   */
  static reset() {
    _TimeController.viObject?.clearAllTimers();
  }
  /**
   * Wait for the next tick of the event loop
   */
  static async waitForNextTick() {
    await new Promise((resolve) => setTimeout(resolve, 0));
    await _TimeController.viObject?.advanceTimersByTimeAsync(0);
  }
};
function withTimeControl(viObject) {
  return (fn) => async () => {
    TimeController.setViObject(viObject);
    viObject.useFakeTimers();
    try {
      await fn(TimeController);
    } finally {
      viObject.useRealTimers();
    }
  };
}
export {
  EventGenerator,
  RelayMock,
  RelayPoolMock,
  SignerGenerator,
  TestEventFactory,
  TestFixture,
  TimeController,
  UserGenerator,
  mockNutzap,
  mockProof,
  withTimeControl
};
