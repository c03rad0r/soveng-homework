import { canHaveHiddenContent, getHiddenContent, getHiddenContentEncryptionMethods, isHiddenContentLocked, lockHiddenContent, unlockHiddenContent, } from "./hidden-content.js";
import { getOrComputeCachedValue } from "./cache.js";
export const HiddenTagsSymbol = Symbol.for("hidden-tags");
/** Checks if an event can have hidden tags */
export function canHaveHiddenTags(kind) {
    return canHaveHiddenContent(kind);
}
/** Checks if an event has hidden tags */
export function hasHiddenTags(event) {
    return canHaveHiddenTags(event.kind) && event.content.length > 0;
}
/** Returns the hidden tags for an event if they are unlocked */
export function getHiddenTags(event) {
    if (isHiddenTagsLocked(event))
        return undefined;
    return getOrComputeCachedValue(event, HiddenTagsSymbol, () => {
        const plaintext = getHiddenContent(event);
        const parsed = JSON.parse(plaintext);
        if (!Array.isArray(parsed))
            throw new Error("Content is not an array of tags");
        // Convert array to tags array string[][]
        return parsed.filter((t) => Array.isArray(t)).map((t) => t.map((v) => String(v)));
    });
}
/** Checks if the hidden tags are locked */
export function isHiddenTagsLocked(event) {
    return isHiddenContentLocked(event);
}
/** Returns either nip04 or nip44 encryption method depending on list kind */
export function getHiddenTagsEncryptionMethods(kind, signer) {
    return getHiddenContentEncryptionMethods(kind, signer);
}
/**
 * Decrypts the private list
 * @param event The list event to decrypt
 * @param signer A signer to use to decrypt the tags
 * @param store An optional EventStore to notify about the update
 * @throws
 */
export async function unlockHiddenTags(event, signer) {
    if (!canHaveHiddenTags(event.kind))
        throw new Error("Event kind does not support hidden tags");
    // unlock hidden content is needed
    if (isHiddenContentLocked(event))
        await unlockHiddenContent(event, signer);
    return getHiddenTags(event);
}
export function lockHiddenTags(event) {
    Reflect.deleteProperty(event, HiddenTagsSymbol);
    lockHiddenContent(event);
}
