import { Filter, NostrEvent } from "nostr-tools";
import { Subject } from "rxjs";
import { LRU } from "../helpers/lru.js";
/**
 * An in-memory database for nostr events
 * NOTE: does not handle replaceable events
 */
export declare class Database {
    protected log: import("debug").Debugger;
    /** Indexes */
    protected kinds: Map<number, Set<import("nostr-tools").Event>>;
    protected authors: Map<string, Set<import("nostr-tools").Event>>;
    protected tags: LRU<Set<import("nostr-tools").Event>>;
    protected created_at: NostrEvent[];
    /** LRU cache of last events touched */
    events: LRU<import("nostr-tools").Event>;
    /** A sorted array of replaceable events by uid */
    protected replaceable: Map<string, import("nostr-tools").Event[]>;
    /** A stream of events inserted into the database */
    inserted: Subject<import("nostr-tools").Event>;
    /** A stream of events that have been updated */
    updated: Subject<import("nostr-tools").Event>;
    /** A stream of events removed from the database */
    removed: Subject<import("nostr-tools").Event>;
    /** A method thats called before a new event is inserted */
    onBeforeInsert?: (event: NostrEvent) => void;
    get size(): number;
    protected claims: WeakMap<import("nostr-tools").Event, any>;
    /** Index helper methods */
    protected getKindIndex(kind: number): Set<import("nostr-tools").Event>;
    protected getAuthorsIndex(author: string): Set<import("nostr-tools").Event>;
    protected getTagIndex(tagAndValue: string): Set<import("nostr-tools").Event>;
    /** Moves an event to the top of the LRU cache */
    touch(event: NostrEvent): void;
    /** Checks if the database contains an event without touching it */
    hasEvent(id: string): boolean;
    /** Gets a single event based on id */
    getEvent(id: string): NostrEvent | undefined;
    /** Checks if the database contains a replaceable event without touching it */
    hasReplaceable(kind: number, pubkey: string, d?: string): boolean;
    /** Gets an array of replaceable events */
    getReplaceable(kind: number, pubkey: string, d?: string): NostrEvent[] | undefined;
    /** Inserts an event into the database and notifies all subscriptions */
    addEvent(event: NostrEvent): NostrEvent;
    /** Inserts and event into the database and notifies all subscriptions that the event has updated */
    updateEvent(event: NostrEvent): NostrEvent;
    /** Removes an event from the database and notifies all subscriptions */
    removeEvent(eventOrId: string | NostrEvent): boolean;
    /** Sets the claim on the event and touches it */
    claimEvent(event: NostrEvent, claim: any): void;
    /** Checks if an event is claimed by anything */
    isClaimed(event: NostrEvent): boolean;
    /** Removes a claim from an event */
    removeClaim(event: NostrEvent, claim: any): void;
    /** Removes all claims on an event */
    clearClaim(event: NostrEvent): void;
    iterateAuthors(authors: Iterable<string>): Generator<NostrEvent>;
    iterateTag(tag: string, values: Iterable<string>): Generator<NostrEvent>;
    iterateKinds(kinds: Iterable<number>): Generator<NostrEvent>;
    iterateTime(since: number | undefined, until: number | undefined): Generator<NostrEvent>;
    iterateIds(ids: Iterable<string>): Generator<NostrEvent>;
    /** Returns all events that match the filter */
    getEventsForFilter(filter: Filter): Set<NostrEvent>;
    getEventsForFilters(filters: Filter[]): Set<NostrEvent>;
    /** Remove the oldest events that are not claimed */
    prune(limit?: number): number;
}
