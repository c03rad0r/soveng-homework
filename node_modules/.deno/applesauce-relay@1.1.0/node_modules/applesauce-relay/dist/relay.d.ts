import { logger } from "applesauce-core";
import { type Filter, type NostrEvent } from "nostr-tools";
import { BehaviorSubject, Observable } from "rxjs";
import { WebSocketSubject, WebSocketSubjectConfig } from "rxjs/webSocket";
import { RelayInformation } from "nostr-tools/nip11";
import { AuthSigner, IRelay, PublishOptions, PublishResponse, RequestOptions, SubscriptionOptions, SubscriptionResponse } from "./types.js";
/** An error that is thrown when a REQ is closed from the relay side */
export declare class ReqCloseError extends Error {
}
export type RelayOptions = {
    WebSocket?: WebSocketSubjectConfig<any>["WebSocketCtor"];
};
export declare class Relay implements IRelay {
    url: string;
    protected log: typeof logger;
    protected socket: WebSocketSubject<any>;
    /** Whether the relay is ready for subscriptions or event publishing. setting this to false will cause all .req and .event observables to hang until the relay is ready */
    protected ready$: BehaviorSubject<boolean>;
    /** A method that returns an Observable that emits when the relay should reconnect */
    reconnectTimer: (error: CloseEvent | Error, attempts: number) => Observable<number>;
    /** How many times the relay has tried to reconnect */
    attempts$: BehaviorSubject<number>;
    /** Whether the relay is connected */
    connected$: BehaviorSubject<boolean>;
    /** The authentication challenge string from the relay */
    challenge$: BehaviorSubject<string | null>;
    /** Whether the client is authenticated with the relay */
    authenticated$: BehaviorSubject<boolean>;
    /** The notices from the relay */
    notices$: BehaviorSubject<string[]>;
    /** The last connection error */
    error$: BehaviorSubject<Error | null>;
    /**
     * A passive observable of all messages from the relay
     * @note Subscribing to this will not connect to the relay
     */
    message$: Observable<any>;
    /**
     * A passive observable of NOTICE messages from the relay
     * @note Subscribing to this will not connect to the relay
     */
    notice$: Observable<string>;
    /** An observable that emits the NIP-11 information document for the relay */
    information$: Observable<RelayInformation | null>;
    protected _nip11: RelayInformation | null;
    /** An observable that emits the limitations for the relay */
    limitations$: Observable<RelayInformation["limitation"] | null>;
    get connected(): boolean;
    get challenge(): string | null;
    get notices(): string[];
    get authenticated(): boolean;
    get information(): RelayInformation | null;
    /** If an EOSE message is not seen in this time, emit one locally  */
    eoseTimeout: number;
    /** How long to wait for an OK message from the relay */
    eventTimeout: number;
    /** How long to keep the connection alive after nothing is subscribed */
    keepAlive: number;
    protected receivedAuthRequiredForReq: BehaviorSubject<boolean>;
    protected receivedAuthRequiredForEvent: BehaviorSubject<boolean>;
    protected authRequiredForReq: Observable<boolean>;
    protected authRequiredForEvent: Observable<boolean>;
    protected resetState(): void;
    /** An internal observable that is responsible for watching all messages and updating state */
    protected watchTower: Observable<never>;
    constructor(url: string, opts?: RelayOptions);
    /** Set ready = false and start the reconnect timer */
    protected startReconnectTimer(error: Error | CloseEvent): void;
    /** Wait for ready and authenticated */
    protected waitForAuth<T extends unknown = unknown>(requireAuth: Observable<boolean>, observable: Observable<T>): Observable<T>;
    /** Wait for the relay to be ready to accept connections */
    protected waitForReady<T extends unknown = unknown>(observable: Observable<T>): Observable<T>;
    multiplex<T>(open: () => any, close: () => any, filter: (message: any) => boolean): Observable<T>;
    /** Send a message to the relay */
    next(message: any): void;
    /** Create a REQ observable that emits events or "EOSE" or errors */
    req(filters: Filter | Filter[], id?: string): Observable<SubscriptionResponse>;
    /** Send an EVENT or AUTH message and return an observable of PublishResponse that completes or errors */
    event(event: NostrEvent, verb?: "EVENT" | "AUTH"): Observable<PublishResponse>;
    /** send and AUTH message */
    auth(event: NostrEvent): Observable<PublishResponse>;
    /** Authenticate with the relay using a signer */
    authenticate(signer: AuthSigner): Observable<PublishResponse>;
    /** Creates a REQ that retries when relay errors ( default 3 retries ) */
    subscription(filters: Filter | Filter[], opts?: SubscriptionOptions): Observable<SubscriptionResponse>;
    /** Makes a single request that retires on errors and completes on EOSE */
    request(filters: Filter | Filter[], opts?: RequestOptions): Observable<NostrEvent>;
    /** Publishes an event to the relay and retries when relay errors or responds with auth-required ( default 3 retries ) */
    publish(event: NostrEvent, opts?: PublishOptions): Observable<PublishResponse>;
    /** Static method to fetch the NIP-11 information document for a relay */
    static fetchInformationDocument(url: string): Observable<RelayInformation | null>;
    /** Static method to create a reconnection method for each relay */
    static createReconnectTimer(_relay: string): (_error?: Error | CloseEvent, tries?: number) => Observable<0>;
}
