import { nanoid } from "nanoid";
import { catchError, EMPTY, endWith, ignoreElements, merge, of } from "rxjs";
import { completeOnEose } from "./operators/complete-on-eose.js";
import { onlyEvents } from "./operators/only-events.js";
export class RelayGroup {
    relays;
    constructor(relays) {
        this.relays = relays;
    }
    /** Takes an array of observables and only emits EOSE when all observables have emitted EOSE */
    mergeEOSE(...requests) {
        // Create stream of events only
        const events = merge(...requests).pipe(onlyEvents());
        // Create stream that emits EOSE when all relays have sent EOSE
        const eose = merge(
        // Create a new map of requests that only emits EOSE
        ...requests.map((observable) => observable.pipe(completeOnEose(), ignoreElements()))).pipe(
        // When all relays have sent EOSE, emit EOSE
        endWith("EOSE"));
        return merge(events, eose);
    }
    /** Make a request to all relays */
    req(filters, id = nanoid(8)) {
        const requests = this.relays.map((relay) => relay.req(filters, id).pipe(
        // Ignore connection errors
        catchError(() => of("EOSE"))));
        // Merge events and the single EOSE stream
        return this.mergeEOSE(...requests);
    }
    /** Send an event to all relays */
    event(event) {
        return merge(...this.relays.map((relay) => relay.event(event).pipe(
        // Catch error and return as PublishResponse
        catchError((err) => of({ ok: false, from: relay.url, message: err?.message || "Unknown error" })))));
    }
    /** Publish an event to all relays with retries ( default 3 retries ) */
    publish(event, opts) {
        return merge(...this.relays.map((relay) => relay.publish(event, opts).pipe(
        // Catch error and return as PublishResponse
        catchError((err) => of({ ok: false, from: relay.url, message: err?.message || "Unknown error" })))));
    }
    /** Request events from all relays with retries ( default 3 retries ) */
    request(filters, opts) {
        return merge(...this.relays.map((relay) => relay.request(filters, opts).pipe(
        // Ignore individual connection errors
        catchError(() => EMPTY))));
    }
    /** Open a subscription to all relays with retries ( default 3 retries ) */
    subscription(filters, opts) {
        return this.mergeEOSE(...this.relays.map((relay) => relay.subscription(filters, opts).pipe(
        // Ignore individual connection errors
        catchError(() => EMPTY))));
    }
}
