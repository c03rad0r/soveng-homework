type Item = {
    timestamp: number;
    id: Uint8Array;
};
declare class WrappedBuffer {
    _raw: Uint8Array;
    length: number;
    constructor(buffer?: any);
    unwrap(): Uint8Array<ArrayBufferLike>;
    get capacity(): number;
    extend(buf: WrappedBuffer | Uint8Array | number[]): void;
    shift(): number;
    shiftN(n?: number): Uint8Array<ArrayBufferLike>;
}
declare class NegentropyStorageVector {
    items: Item[];
    sealed: boolean;
    constructor();
    insert(timestamp: number, id: Uint8Array | string): void;
    seal(): void;
    unseal(): void;
    size(): number;
    getItem(i: number): Item;
    iterate(begin: number, end: number, cb: (item: Item, i: number) => boolean): void;
    findLowerBound(begin: number, end: number, bound: Item): number;
    fingerprint(begin: number, end: number): Promise<Uint8Array<ArrayBufferLike>>;
    _checkSealed(): void;
    _checkBounds(begin: number, end: number): void;
    _binarySearch<T>(arr: T[], first: number, last: number, cmp: (a: T) => boolean): number;
}
declare class Negentropy {
    storage: NegentropyStorageVector;
    frameSizeLimit: number;
    lastTimestampIn: number;
    lastTimestampOut: number;
    isInitiator?: boolean;
    wantUint8ArrayOutput?: boolean;
    constructor(storage: NegentropyStorageVector, frameSizeLimit?: number);
    _bound(timestamp: number, id?: Uint8Array): {
        timestamp: number;
        id: Uint8Array<ArrayBuffer>;
    };
    initiate<T extends Uint8Array | string>(): Promise<T>;
    setInitiator(): void;
    reconcile<T extends Uint8Array | string>(input: Uint8Array | string): Promise<[T | null, T[], T[]]>;
    splitRange(lower: number, upper: number, upperBound: Item, o: WrappedBuffer): Promise<void>;
    _renderOutput<T extends Uint8Array | string>(o: WrappedBuffer): T;
    exceededFrameSizeLimit(n: number): boolean | 0;
    decodeTimestampIn(encoded: WrappedBuffer): number;
    decodeBound(encoded: WrappedBuffer): {
        timestamp: number;
        id: Uint8Array<ArrayBufferLike>;
    };
    encodeTimestampOut(timestamp: number): WrappedBuffer;
    encodeBound(key: Item): WrappedBuffer;
    getMinimalBound(prev: Item, curr: Item): {
        timestamp: number;
        id: Uint8Array<ArrayBuffer>;
    };
}
export { Negentropy, NegentropyStorageVector };
