import { EventTemplate, Filter, NostrEvent, verifyEvent } from "nostr-tools";
import { Nip07Interface, SimpleSigner } from "applesauce-signers";
import { Deferred } from "applesauce-core/promise";
export declare function isErrorResponse(response: any): response is NostrConnectErrorResponse;
export declare enum Permission {
    GetPublicKey = "get_pubic_key",
    SignEvent = "sign_event",
    Nip04Encrypt = "nip04_encrypt",
    Nip04Decrypt = "nip04_decrypt",
    Nip44Encrypt = "nip44_encrypt",
    Nip44Decrypt = "nip44_decrypt"
}
export declare enum NostrConnectMethod {
    Connect = "connect",
    CreateAccount = "create_account",
    GetPublicKey = "get_public_key",
    SignEvent = "sign_event",
    Nip04Encrypt = "nip04_encrypt",
    Nip04Decrypt = "nip04_decrypt",
    Nip44Encrypt = "nip44_encrypt",
    Nip44Decrypt = "nip44_decrypt"
}
type RequestParams = {
    [NostrConnectMethod.Connect]: [string] | [string, string] | [string, string, string];
    [NostrConnectMethod.CreateAccount]: [string, string] | [string, string, string] | [string, string, string, string];
    [NostrConnectMethod.GetPublicKey]: [];
    [NostrConnectMethod.SignEvent]: [string];
    [NostrConnectMethod.Nip04Encrypt]: [string, string];
    [NostrConnectMethod.Nip04Decrypt]: [string, string];
    [NostrConnectMethod.Nip44Encrypt]: [string, string];
    [NostrConnectMethod.Nip44Decrypt]: [string, string];
};
type ResponseResults = {
    [NostrConnectMethod.Connect]: "ack";
    [NostrConnectMethod.CreateAccount]: string;
    [NostrConnectMethod.GetPublicKey]: string;
    [NostrConnectMethod.SignEvent]: string;
    [NostrConnectMethod.Nip04Encrypt]: string;
    [NostrConnectMethod.Nip04Decrypt]: string;
    [NostrConnectMethod.Nip44Encrypt]: string;
    [NostrConnectMethod.Nip44Decrypt]: string;
};
export type NostrConnectRequest<N extends NostrConnectMethod> = {
    id: string;
    method: N;
    params: RequestParams[N];
};
export type NostrConnectResponse<N extends NostrConnectMethod> = {
    id: string;
    result: ResponseResults[N];
    error?: string;
};
export type NostrConnectErrorResponse = {
    id: string;
    result: string;
    error: string;
};
export type NostrConnectSignerOptions = {
    /** The relays to communicate over */
    relays: string[];
    /** A {@link SimpleSigner} for this client */
    signer?: SimpleSigner;
    /** pubkey of the remote signer application */
    remote?: string;
    /** Users pubkey */
    pubkey?: string;
    /** A method for handling "auth" requests */
    onAuth?: (url: string) => Promise<void>;
    /** A method for subscribing to relays */
    subscriptionMethod?: NostrSubscriptionMethod;
    /** A method for publishing events */
    publishMethod?: NostrPublishMethod;
};
interface Unsubscribable {
    unsubscribe(): void;
}
interface Observer<T> {
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
type Subscribable<T extends unknown> = {
    subscribe: (observer: Partial<Observer<T>>) => Unsubscribable;
};
export type NostrSubscriptionMethod = (relays: string[], filters: Filter[]) => Subscribable<NostrEvent>;
export type NostrPublishMethod = (relays: string[], event: NostrEvent) => void | Promise<void>;
export type NostrConnectAppMetadata = {
    name?: string;
    image?: string;
    url?: string | URL;
    permissions?: string[];
};
export declare class NostrConnectSigner implements Nip07Interface {
    /** A method that is called when an event needs to be published */
    protected publishMethod: NostrPublishMethod;
    /** The active nostr subscription */
    protected subscriptionMethod: NostrSubscriptionMethod;
    protected log: import("debug").Debugger;
    /** The local client signer */
    signer: SimpleSigner;
    protected subscriptionOpen: boolean;
    /** Whether the signer is connected to the remote signer */
    isConnected: boolean;
    /** The users pubkey */
    protected pubkey?: string;
    /** Relays to communicate over */
    relays: string[];
    /** The remote signer pubkey */
    remote?: string;
    /** Client pubkey */
    get clientPubkey(): string;
    /** A method for handling "auth" requests */
    onAuth: (url: string) => Promise<void>;
    verifyEvent: typeof verifyEvent;
    /** A secret used when initiating a connection from the client side */
    protected clientSecret: string;
    nip04?: {
        encrypt: (pubkey: string, plaintext: string) => Promise<string> | string;
        decrypt: (pubkey: string, ciphertext: string) => Promise<string> | string;
    } | undefined;
    nip44?: {
        encrypt: (pubkey: string, plaintext: string) => Promise<string> | string;
        decrypt: (pubkey: string, ciphertext: string) => Promise<string> | string;
    } | undefined;
    /** A fallback method to use for subscriptionMethod if none is pass in when creating the signer */
    static subscriptionMethod: NostrSubscriptionMethod | undefined;
    /** A fallback method to use for publishMethod if none is pass in when creating the signer */
    static publishMethod: NostrPublishMethod | undefined;
    constructor(opts: NostrConnectSignerOptions);
    /** The currently active REQ subscription */
    protected req?: Unsubscribable;
    /** Open the connection */
    open(): Promise<void>;
    /** Close the connection */
    close(): Promise<void>;
    protected requests: Map<string, Deferred<any>>;
    protected auths: Set<string>;
    /** Call this method with incoming events */
    handleEvent(event: NostrEvent): Promise<void>;
    protected createRequestEvent(content: string, target?: string | undefined, kind?: number): Promise<import("nostr-tools").VerifiedEvent>;
    private makeRequest;
    /** Connect to remote signer */
    connect(secret?: string | undefined, permissions?: string[]): Promise<"ack">;
    private waitingPromise;
    /** Wait for a remote signer to connect */
    waitForSigner(): Promise<void>;
    /** Request to create an account on the remote signer */
    createAccount(username: string, domain: string, email?: string, permissions?: string[]): Promise<string>;
    /** Ensure the signer is connected to the remote signer */
    requireConnection(): Promise<void>;
    /** Get the users pubkey */
    getPublicKey(): Promise<string>;
    /** Request to sign an event */
    signEvent(template: EventTemplate & {
        pubkey?: string;
    }): Promise<import("nostr-tools").VerifiedEvent>;
    nip04Encrypt(pubkey: string, plaintext: string): Promise<string>;
    nip04Decrypt(pubkey: string, ciphertext: string): Promise<string>;
    nip44Encrypt(pubkey: string, plaintext: string): Promise<string>;
    nip44Decrypt(pubkey: string, ciphertext: string): Promise<string>;
    /** Returns the nostrconnect:// URI for this signer */
    getNostrConnectURI(metadata?: NostrConnectAppMetadata): string;
    /** Parses a bunker:// URI */
    static parseBunkerURI(uri: string): {
        remote: string;
        relays: string[];
        secret?: string;
    };
    /** Builds an array of signing permissions for event kinds */
    static buildSigningPermissions(kinds: number[]): string[];
    /** Create a {@link NostrConnectSigner} from a bunker:// URI */
    static fromBunkerURI(uri: string, options?: Omit<NostrConnectSignerOptions, "relays"> & {
        permissions?: string[];
        signer?: SimpleSigner;
    }): Promise<NostrConnectSigner>;
}
export {};
